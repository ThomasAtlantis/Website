<blockquote data-pid="JkHx-gmN">请Python没入门的撤离此系列文章，请不要随意使用，请不要走火入魔</blockquote><p data-pid="tz1YSdcI">在网上闲逛的时候偶然看到StackOverflow上的一个9年前的老帖子：<a href="http://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/6738987/extension-method-for-python-built-in-types" class=" wrap external" target="_blank" rel="nofollow noreferrer">Extension method for python built-in types</a>。修改Python的内置数据类型的属性和方法，我以前也在具体的场景中有过这种念头。但对于我来说这个问题可怕且无解，往往是绕道而行。<b>一方面，其中涉及到的技术必然十分复杂；另一方面，对Python语言本身的破坏，必然严重损害业务逻辑的可读性。</b>如今仔细研究了一下，发现其中不仅具有技术意义，也不乏娱乐效果。发现网上对这个的研究并不多，对其方法的详解更是少之又少，在此做如下总结。</p><h2>为什么说具有娱乐性？</h2><p data-pid="sLO1zSVK">有人为修改内置类型专门写了一个工具，叫做<a href="http://link.zhihu.com/?target=https%3A//clarete.li/forbiddenfruit/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Forbiddenfruit</a>，翻译过来就是禁果。</p><p data-pid="5LF46wd4">禁果是在《圣经》中伊甸园“知善恶树”上结的果实。旧约创世纪记载，神对亚当及夏娃说园中树上的果子都可以吃，唯“知善恶树”上的果实“不可吃、也不可摸”，否则他们便会死。最后夏娃受魔鬼的引诱，不顾上帝的吩咐进食了禁果，又把果子给了亚当，他也吃了。上帝便把他们赶出伊甸园。偷食禁果被认为是人类的原罪及一切其它罪恶的开端。</p><p data-pid="lG2xPvFH">同样，修改Python的内置类型就是禁果，吃了它，你可以打开新世界的大门，但也很有可能进入编程的歪门邪道而走火入魔。破解语言本身就是编程的原罪。如果说程序世界是众神铸就的，对于神创造的内置类型就应该继承而不是重建。但同时，这种渎神的行为又可以认为是人的自我意识的觉醒，包含在编程技术中漫漫求索的开拓精神，故也是可取的。这里开个玩笑，只是感叹一下禁果这个词很形象。你可以使用如下语句进行安装：</p><div class="highlight"><pre><code class="language-bash"><span></span>pip install forbiddenfruit
</code></pre></div><p data-pid="4iHTrZtr">该库的<a href="http://link.zhihu.com/?target=https%3A//pypi.org/project/forbiddenfruit/" class=" wrap external" target="_blank" rel="nofollow noreferrer">PyPi传送门</a>，<a href="http://link.zhihu.com/?target=https%3A//github.com/clarete/forbiddenfruit" class=" wrap external" target="_blank" rel="nofollow noreferrer">GitHub传送门</a>。这里不展开该库的使用方法，毕竟调包没什么好说的，值得一提的是它修改内置类型的方法叫做curse诅咒，还可以使用reverse反转诅咒，作者一定是个有趣的灵魂。下面详解一下SO上高赞的回答给出的方法。我对它进行了小小的加工，因为该回答使用Python2.x过于陈旧。</p><h2>借助CPython修改内置类型的原理</h2><p data-pid="QxfXdPJN">我们以内置类型list为例，可以通过__dict__观察其包含了哪些属性和方法</p><div class="highlight"><pre><code class="language-python"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="nb">list</span><span class="o">.</span><span class="vm">__dict__</span>
<span class="n">mappingproxy</span><span class="p">({</span><span class="s1">'__repr__'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">slot</span> <span class="n">wrapper</span> <span class="s1">'__repr__'</span> <span class="n">of</span> <span class="s1">'list'</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="s1">'__hash__'</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
              <span class="s1">'__getattribute__'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">slot</span> <span class="n">wrapper</span> <span class="s1">'__getattribute__'</span> <span class="n">of</span> <span class="s1">'list'</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="s1">'__lt__'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">slot</span> <span class="n">wrapper</span> <span class="s1">'__lt__'</span> <span class="n">of</span> <span class="s1">'list'</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="s1">'__le__'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">slot</span> <span class="n">wrapper</span> <span class="s1">'__le__'</span> <span class="n">of</span> <span class="s1">'list'</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="s1">'__eq__'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">slot</span> <span class="n">wrapper</span> <span class="s1">'__eq__'</span> <span class="n">of</span> <span class="s1">'list'</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="s1">'__ne__'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">slot</span> <span class="n">wrapper</span> <span class="s1">'__ne__'</span> <span class="n">of</span> <span class="s1">'list'</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="s1">'__gt__'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">slot</span> <span class="n">wrapper</span> <span class="s1">'__gt__'</span> <span class="n">of</span> <span class="s1">'list'</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="s1">'__ge__'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">slot</span> <span class="n">wrapper</span> <span class="s1">'__ge__'</span> <span class="n">of</span> <span class="s1">'list'</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="s1">'__iter__'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">slot</span> <span class="n">wrapper</span> <span class="s1">'__iter__'</span> <span class="n">of</span> <span class="s1">'list'</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="s1">'__init__'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">slot</span> <span class="n">wrapper</span> <span class="s1">'__init__'</span> <span class="n">of</span> <span class="s1">'list'</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="s1">'__len__'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">slot</span> <span class="n">wrapper</span> <span class="s1">'__len__'</span> <span class="n">of</span> <span class="s1">'list'</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="s1">'__getitem__'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">method</span> <span class="s1">'__getitem__'</span> <span class="n">of</span> <span class="s1">'list'</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="s1">'__setitem__'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">slot</span> <span class="n">wrapper</span> <span class="s1">'__setitem__'</span> <span class="n">of</span> <span class="s1">'list'</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="s1">'__delitem__'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">slot</span> <span class="n">wrapper</span> <span class="s1">'__delitem__'</span> <span class="n">of</span> <span class="s1">'list'</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="s1">'__add__'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">slot</span> <span class="n">wrapper</span> <span class="s1">'__add__'</span> <span class="n">of</span> <span class="s1">'list'</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="s1">'__mul__'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">slot</span> <span class="n">wrapper</span> <span class="s1">'__mul__'</span> <span class="n">of</span> <span class="s1">'list'</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="s1">'__rmul__'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">slot</span> <span class="n">wrapper</span> <span class="s1">'__rmul__'</span> <span class="n">of</span> <span class="s1">'list'</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="s1">'__contains__'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">slot</span> <span class="n">wrapper</span> <span class="s1">'__contains__'</span> <span class="n">of</span> <span class="s1">'list'</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="s1">'__iadd__'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">slot</span> <span class="n">wrapper</span> <span class="s1">'__iadd__'</span> <span class="n">of</span> <span class="s1">'list'</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="s1">'__imul__'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">slot</span> <span class="n">wrapper</span> <span class="s1">'__imul__'</span> <span class="n">of</span> <span class="s1">'list'</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="s1">'__new__'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">function</span> <span class="nb">list</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="s1">'__reversed__'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">method</span> <span class="s1">'__reversed__'</span> <span class="n">of</span> <span class="s1">'list'</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="s1">'__sizeof__'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">method</span> <span class="s1">'__sizeof__'</span> <span class="n">of</span> <span class="s1">'list'</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="s1">'clear'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">method</span> <span class="s1">'clear'</span> <span class="n">of</span> <span class="s1">'list'</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="s1">'copy'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">method</span> <span class="s1">'copy'</span> <span class="n">of</span> <span class="s1">'list'</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="s1">'append'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">method</span> <span class="s1">'append'</span> <span class="n">of</span> <span class="s1">'list'</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="s1">'insert'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">method</span> <span class="s1">'insert'</span> <span class="n">of</span> <span class="s1">'list'</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="s1">'extend'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">method</span> <span class="s1">'extend'</span> <span class="n">of</span> <span class="s1">'list'</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="s1">'pop'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">method</span> <span class="s1">'pop'</span> <span class="n">of</span> <span class="s1">'list'</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="s1">'remove'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">method</span> <span class="s1">'remove'</span> <span class="n">of</span> <span class="s1">'list'</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="s1">'index'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">method</span> <span class="s1">'index'</span> <span class="n">of</span> <span class="s1">'list'</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="s1">'count'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">method</span> <span class="s1">'count'</span> <span class="n">of</span> <span class="s1">'list'</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="s1">'reverse'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">method</span> <span class="s1">'reverse'</span> <span class="n">of</span> <span class="s1">'list'</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="s1">'sort'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">method</span> <span class="s1">'sort'</span> <span class="n">of</span> <span class="s1">'list'</span> <span class="n">objects</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="s1">'__doc__'</span><span class="p">:</span> <span class="s2">"list() -&gt; new empty list</span><span class="se">\n</span><span class="s2">list(iterable) -&gt; new list initialized from iterable's items"</span><span class="p">})</span>
</code></pre></div><p data-pid="_OokzMqK">也许是偶然的机会，先贤们发现，<b>通过修改内置类型的__dict__字典内容，可以为其添加属性和方法</b>。然而从结果可以看出，__dict__属于mappingproxy类型，即不可变映射类型：</p><div class="highlight"><pre><code class="language-python"><span></span><span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">MappingProxyType</span>
<span class="n">d_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="s2">"hello"</span><span class="p">))</span>
<span class="n">d_prxy</span> <span class="o">=</span> <span class="n">MappingProxyType</span><span class="p">(</span><span class="n">d_dict</span><span class="p">)</span>
<span class="c1"># mappingproxy({0: 'h', 1: 'e', 2: 'l', 3: 'l', 4: 'o'})</span>
</code></pre></div><p data-pid="FKzNbrI1">我们无法直接对其进行修改，赋值操作将会引发错误：</p><div class="highlight"><pre><code class="language-python"><span></span><span class="n">d_prxy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'z'</span>
<span class="c1"># TypeError: 'mappingproxy' object does not support item assignment</span>
</code></pre></div><p data-pid="i3qaKFgL">这里我们需要参考Python的C语言实现源码来操作内存，从而绕过这个限制。由于整个Python语言从规范到解释器都是开源的，所以存在不同版本的具体实现。CPython是指C语言实现的Python解释器，也是应用最广泛的官方Python解释器。其中ctypes等库提供了C语言的调用接口，常常用来做混合编程。使用C语言将一些常用方法重写可以一定程度提升Python程序的运行速度。后来Python实现的Python解释器PyPy，提供了一种速度更快的替代方案，这里我们只讨论CPython。注意CPython不是Cython，这是两个不同的概念。</p><p data-pid="LE16mSKv">参考<a href="http://link.zhihu.com/?target=https%3A//github.com/python/cpython" class=" wrap external" target="_blank" rel="nofollow noreferrer">Python源码</a>的descrobject.c.h和descrobject.c文件中对新建mappingproxy的方法的声明与实现，发现其返回值实际上就是PyObject类型的一个指针，我们只要从内存中找到这个指针指向的内容，再将其读取出来即可。<b>值得庆幸的是，Python的id函数查看到的id值实际上就是CPython中对象的内存地址。</b></p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="c1">// descrobject.c.h</span>
<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">mappingproxy_new_impl</span><span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">mapping</span><span class="p">);</span>
<span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">mappingproxy_new</span><span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwargs</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">return_value</span> <span class="o">=</span> <span class="n">mappingproxy_new_impl</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">mapping</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="c1">//descrobject.c</span>
<span class="cm">/*[clinic input]</span>
<span class="cm">@classmethod</span>
<span class="cm">mappingproxy.__new__ as mappingproxy_new</span>
<span class="cm">    mapping: object</span>
<span class="cm">[clinic start generated code]*/</span> 
<span class="n">mappingproxy_new_impl</span><span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">mapping</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">mappingproxy</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h2>修改内置类型的编程实现详解</h2><p data-pid="zayHpMGn">首先引入ctypes库，它提供了与 C 兼容的数据类型，并允许调用 DLL 或共享库中的函数。可使用该模块以纯 Python 形式对这些库进行封装。</p><div class="highlight"><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">ctypes</span>
</code></pre></div><p data-pid="QjvtJ_Fp">然后我们参照Python源码中对PyObject的定义，来实现Python版本的定义，参考：<a href="http://link.zhihu.com/?target=https%3A//www.cnblogs.com/wangxx06/p/13052316.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">Python基础 | 1.Python对象初探</a>。</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_object</span> <span class="p">{</span>
    <span class="n">_PyObject_HEAD_EXTRA</span>
    <span class="n">Py_ssize_t</span> <span class="n">ob_refcnt</span><span class="p">;</span>
    <span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">ob_type</span><span class="p">;</span>
<span class="p">}</span> <span class="n">PyObject</span><span class="p">;</span>
</code></pre></div><p data-pid="4T1f1B0i">_PyObject_HEAD_EXTRA可以不用管，这个宏仅仅在DEBUG模式下起作用，所以PyObject是一个只有两个成员变量的结构体。在Python2.5中，Py_ssize_t处使用的是int，因此可以认为它和int的效果是一样的。Python为了容纳64位体系结构在后来的版本中创建了Py_ssize_t类型作为索引的类型，其位数等于系统位数。所以可以认为Py_ssize_t的本质就是 int。下面用Python实现这部分定义：</p><div class="highlight"><pre><code class="language-python"><span></span><span class="k">class</span> <span class="nc">PyObject</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">Structure</span><span class="p">):</span>
    <span class="k">class</span> <span class="nc">PyType</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">Structure</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="n">ssize</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int64</span> <span class="k">if</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">sizeof</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">8</span> <span class="k">else</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int32</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s1">'ob_refcnt'</span><span class="p">,</span> <span class="n">ssize</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">'ob_type'</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">PyType</span><span class="p">)),</span>
    <span class="p">]</span>
</code></pre></div><p data-pid="tIKbXSMd">其中ctypes.c_void_p指的C语言的泛指针void*，sizeof得到它所占字节数，如果是8位，说明是64位系统，ssize应为int64，否则应为int32。这里定义的ob_type是PyType的指针，因为指针类型所占空间大小其实是一样的。也可以把PyObject的声明独立出来，然后ob_type设置为PyObject的指针。</p><p data-pid="YvEmdlXA">接下来我们读取并修改__dict__的内容，这里为了优雅，定义一个函数装饰器：</p><div class="highlight"><pre><code class="language-python"><span></span><span class="k">def</span> <span class="nf">sign</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="n">func_name</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
        <span class="k">class</span> <span class="nc">SlotsProxy</span><span class="p">(</span><span class="n">PyObject</span><span class="p">):</span>
            <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">'dict'</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">PyObject</span><span class="p">))]</span>

        <span class="n">name</span><span class="p">,</span> <span class="n">target</span> <span class="o">=</span> <span class="n">klass</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">klass</span><span class="o">.</span><span class="vm">__dict__</span>
        <span class="n">proxy_dict</span> <span class="o">=</span> <span class="n">SlotsProxy</span><span class="o">.</span><span class="n">from_address</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>
        <span class="n">namespace</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">pythonapi</span><span class="o">.</span><span class="n">PyDict_SetItem</span><span class="p">(</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">py_object</span><span class="p">(</span><span class="n">namespace</span><span class="p">),</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">py_object</span><span class="p">(</span><span class="n">name</span><span class="p">),</span>
            <span class="n">proxy_dict</span><span class="o">.</span><span class="n">dict</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">namespace</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">func_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">function</span>
    <span class="k">return</span> <span class="n">_</span>
</code></pre></div><p data-pid="n0OdvY2j">装饰器的参数klass为内置类型，比如list、int，func_name是添加的方法的名称。_只是代表变量（函数）的名字不重要。这里我们使用了ctypes.Structure的方法from_address来从内存构造proxy_dict对象。（SlotsProxy继承PyObject，后者又继承了ctypes.Structure）然后使用ctypes.pythonapi.PyDict_SetItem来为字典namespace添加一条内容，第一个参数是Python的字典，第二个参数是将要添加到字典中的item的key，第三个参数对应item的value。proxy_dict读出来的内容一开始只能看到类型。但这个类型是C语言的类型，是无法直接输出的，必须通过类似以上方法setitem然后读取item，才能输出出来。</p><div class="highlight"><pre><code class="language-python"><span></span><span class="o">&lt;</span><span class="n">__main__</span><span class="o">.</span><span class="n">sign</span><span class="o">.&lt;</span><span class="nb">locals</span><span class="o">&gt;.</span><span class="n">_</span><span class="o">.&lt;</span><span class="nb">locals</span><span class="o">&gt;.</span><span class="n">SlotsProxy</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x7f084dc1b8c8</span><span class="o">&gt;</span>
</code></pre></div><p data-pid="XCVzpVlt">这里有一个小细节，我们必须将klass.__dict__赋值给target然后传入id，而不能直接将其传入，这里我还没有想明白为什么，可能是from_address要求参数为引用的地址，而不是对象本身的地址。我们可以看到二者是不同的：</p><div class="highlight"><pre><code class="language-python"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="nb">id</span><span class="p">(</span><span class="nb">list</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
<span class="mi">139673641478088</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">target</span> <span class="o">=</span> <span class="nb">list</span><span class="o">.</span><span class="vm">__dict__</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">id</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
<span class="mi">139673641478136</span>
</code></pre></div><p data-pid="SxkCbncO">通过这种方法，我们可以为内置类型添加函数也可以添加属性，只需要在function处传入要添加的值即可。调用方法如下：</p><div class="highlight"><pre><code class="language-python"><span></span><span class="c1"># method-1</span>
<span class="nd">@sign</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="s1">'mean'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="n">l</span><span class="p">):</span> <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>

<span class="c1"># method-2</span>
<span class="n">sign</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="s1">'mean'</span><span class="p">)(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
</code></pre></div><p data-pid="qSnAdhHU">然后我们就可以快乐地使用如下方法了！快乐之余再次强调，除非你的团队都知道你改写了内置类型，或者说你只是个人开发工具类，否则不要这么做，会被队友打死！！！</p><div class="highlight"><pre><code class="language-python"><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>  <span class="c1"># 2.5</span>
</code></pre></div><h2>未来工作：内置类型的运算符重载</h2><p data-pid="fKIwHVAc">在最上面输出的<code>__dict__</code>结果中可以看到，内置类型的特殊函数，比如<code>__repr__</code>和运算符对应的函数的类型为<code>slot_wrapper</code>。如果直接定义名为<code>__XXXX__</code>的函数添加进去显然不行，无法实现运算符的重载。这里的wrapper指的是像<code>len()</code>这样既可以在外面包裹着对象执行又可以通过对象的方法<code>__len__()</code>执行的函数。这里的<code>slot_wrapper</code>更特殊一些，在源码中可以找到它的实现，但想要修改它，就需要一种新的hack技巧，类似于修改<code>__dict__</code>这样的技巧。</p><p data-pid="rxh30_GD">据我所知，目前还没有人找到解决方案。以上提到的forbiddenFruit也不支持这件事，可以从它的issue中看到对这件事的讨论：</p><p data-pid="eq1RoYU5"><a href="http://link.zhihu.com/?target=https%3A//github.com/clarete/forbiddenfruit/issues/11" class=" wrap external" target="_blank" rel="nofollow noreferrer">Is (and/or Why) __str__, __repr__ are not patchable? · Issue #11 · clarete/forbiddenfruit</a></p><p data-pid="MsAJCza7">作者是这么说的：</p><blockquote data-pid="Voay0qfc">It's possible but might take some digging to find out what to overwrite.</blockquote><p data-pid="5GUoyXyO">我尝试了很多方法但都没有成功，还请有良策的大佬们不吝赐教~</p><h2>附录：完整代码</h2><div class="highlight"><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">ctypes</span>


<span class="k">class</span> <span class="nc">PyObject</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">Structure</span><span class="p">):</span>
    <span class="k">class</span> <span class="nc">PyType</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">Structure</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="n">ssize</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int64</span> <span class="k">if</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">sizeof</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">8</span> <span class="k">else</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int32</span>
    <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s1">'ob_refcnt'</span><span class="p">,</span> <span class="n">ssize</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">'ob_type'</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">PyType</span><span class="p">)),</span>
    <span class="p">]</span>


<span class="k">def</span> <span class="nf">sign</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="n">func_name</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
        <span class="k">class</span> <span class="nc">SlotsProxy</span><span class="p">(</span><span class="n">PyObject</span><span class="p">):</span>
            <span class="n">_fields_</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">'dict'</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">PyObject</span><span class="p">))]</span>

        <span class="n">name</span><span class="p">,</span> <span class="n">target</span> <span class="o">=</span> <span class="n">klass</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">klass</span><span class="o">.</span><span class="vm">__dict__</span>
        <span class="n">proxy_dict</span> <span class="o">=</span> <span class="n">SlotsProxy</span><span class="o">.</span><span class="n">from_address</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>
        <span class="n">namespace</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">pythonapi</span><span class="o">.</span><span class="n">PyDict_SetItem</span><span class="p">(</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">py_object</span><span class="p">(</span><span class="n">namespace</span><span class="p">),</span>
            <span class="n">ctypes</span><span class="o">.</span><span class="n">py_object</span><span class="p">(</span><span class="n">name</span><span class="p">),</span>
            <span class="n">proxy_dict</span><span class="o">.</span><span class="n">dict</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">namespace</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">func_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">function</span>

    <span class="k">return</span> <span class="n">_</span>

<span class="c1"># method-1</span>
<span class="nd">@sign</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="s1">'mean'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="n">l</span><span class="p">):</span> <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

<span class="c1"># method-2</span>
<span class="c1"># sign(list, 'mean')(lambda l: sum(l) / len(l)</span>

<span class="nb">print</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>  <span class="c1"># 2.5</span>
</code></pre></div><hr><p data-pid="uAXdaPzY">下一篇文章将讲解本文提到的SO大神其余的代码，他不仅实现了内置类型的修改，还实现了一个有趣的Demo：列表的Foreach功能。本文是对这个Demo的铺垫，而其具体逻辑其实和修改内置类型的部分独立。只能说非常难懂，对着毫无可读性的代码想骂人，但理解之后又是拍案称奇。给大家预告一下：</p><div class="highlight"><pre><code class="language-python"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">string</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">foreach</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">str</span><span class="p">()</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">' cookies'</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="s1">', '</span><span class="p">)</span>
<span class="mi">3</span> <span class="n">COOKIES</span><span class="p">,</span> <span class="mi">4</span> <span class="n">COOKIES</span><span class="p">,</span> <span class="mi">5</span> <span class="n">COOKIES</span>
</code></pre></div><p data-pid="FiAmg7Ve">而我做了一些小改进，可以实现foreach中执行自定义的lambda函数，敬请期待</p><hr><p data-pid="SvpCIyX9"><b>2022年7月24日更新</b></p><p data-pid="cKzjP0bb">提供一种更简单的改变内置类属性的方法，借助python的垃圾回收：</p><div class="highlight"><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">gc</span>

<span class="n">gc</span><span class="o">.</span><span class="n">get_referents</span><span class="p">(</span><span class="nb">str</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="s1">'name'</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"hello"</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"abc"</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</code></pre></div><p></p>