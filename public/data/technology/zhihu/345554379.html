<h2>引言</h2><p data-pid="w0tZ7feG">我们知道在诸多高级语言中都包含foreach方法，但这里讨论的更类似于JavaScript中的：</p><div class="highlight"><pre><code class="language-js"><span></span><span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'a'</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">,</span> <span class="s1">'c'</span><span class="p">];</span>
<span class="nx">array</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">element</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">element</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div><p data-pid="GxO7eO04">列表对象直接调用foreach方法，并在其中对每个元素做一些事情。我们的实现效果如下：</p><div class="highlight"><pre><code class="language-python"><span></span><span class="n">bins</span> <span class="o">=</span> <span class="nb">list</span><span class="p">([</span><span class="s1">'1'</span><span class="p">,</span> <span class="s1">'2'</span><span class="p">,</span> <span class="s1">'3'</span><span class="p">,</span> <span class="s1">'4'</span><span class="p">]</span><span class="o">.</span><span class="n">foreach</span><span class="o">.</span><span class="n">int</span><span class="p">()</span><span class="o">.</span><span class="n">do</span><span class="p">(</span>
    <span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="nb">bin</span><span class="p">(</span><span class="n">_</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]</span>
<span class="p">)</span><span class="o">.</span><span class="n">do</span><span class="p">(</span>
    <span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="s2">"</span><span class="si">{:0&gt;4}</span><span class="s2">"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
<span class="p">))</span>
</code></pre></div><p data-pid="6rBf0lhn">其实我们通过Python的map函数也可以实现，这里只是提供另一种写起来优（奇）雅（葩）的思路，主要目的是学习它的实现逻辑而不是实现结果。如果非要抬杠，广泛意义上讲Python语法中本就包含foreach逻辑：</p><div class="highlight"><pre><code class="language-python"><span></span><span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span> <span class="o">...</span>
</code></pre></div><p data-pid="e865L00U">本文是 <a href="https://zhuanlan.zhihu.com/p/345547458" class="internal" target="_blank">Python修改内置类型的属性和方法</a> 的后续，下面继续讲解上文提到的SO大神的回答 <a href="http://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/6738987/extension-method-for-python-built-in-types%23answer-15975791" class=" wrap external" target="_blank" rel="nofollow noreferrer">Answer - Extension method for python built-in types</a> 中提供的foreach方法。我做了一些小改进，其中包括调整代码对Python3.x的兼容性以及实现foreach中执行自定义的lambda函数</p><p data-pid="exr6grXf">同样Python基础知识掌握的不牢固的话，看这篇文章也会稍显吃力~</p><h2>程序实现的全文</h2><p data-pid="WAr1RkGd">话不多说，先上代码。由于这份代码里有些故意炫技的成分，所以很不好读懂，待我慢慢说来。由于逻辑紧密很难切分，先给出全文，再慢慢解释。对于foreach的定义如下：</p><div class="highlight"><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">functools</span>

<span class="k">def</span> <span class="nf">die</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">raise</span> <span class="bp">cls</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">unguido</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
        <span class="nb">getattr</span><span class="p">(</span><span class="n">__builtins__</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="ow">or</span> <span class="n">die</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">),</span>
        <span class="bp">self</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">mapper</span><span class="p">():</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterator</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iterator</span> <span class="o">=</span> <span class="n">iterator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">o</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">'iterator'</span><span class="p">,</span> <span class="s1">'fn'</span><span class="p">,</span> <span class="s1">'key'</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">==</span> <span class="s1">'do'</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fn</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">args</span> <span class="k">else</span> <span class="k">lambda</span> <span class="n">o</span><span class="p">:</span> <span class="n">o</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">o</span><span class="p">:</span> <span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                                 <span class="ow">or</span> <span class="n">unguido</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">))(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterator</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">foreach</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterator</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iterator</span> <span class="o">=</span> <span class="n">iterator</span>

    <span class="k">def</span> <span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">'iterator'</span><span class="p">,):</span>
            <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mapper</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iterator</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterator</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">value</span>
</code></pre></div><p data-pid="6NB3JLlw">使用前文提到的装饰器将foreach注册到list的方法字典中：</p><div class="highlight"><pre><code class="language-python"><span></span><span class="n">sign</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="s1">'foreach'</span><span class="p">)(</span><span class="nb">property</span><span class="p">(</span><span class="n">foreach</span><span class="p">))</span>
</code></pre></div><p data-pid="tikzDr1v">然后调用本文引言中的方法，将十进制字符串列表转为4位二进制字符串列表：</p><div class="highlight"><pre><code class="language-python"><span></span><span class="n">bins</span> <span class="o">=</span> <span class="nb">list</span><span class="p">([</span><span class="s1">'1'</span><span class="p">,</span> <span class="s1">'2'</span><span class="p">,</span> <span class="s1">'3'</span><span class="p">,</span> <span class="s1">'4'</span><span class="p">]</span><span class="o">.</span><span class="n">foreach</span><span class="o">.</span><span class="n">int</span><span class="p">()</span><span class="o">.</span><span class="n">do</span><span class="p">(</span>
    <span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="nb">bin</span><span class="p">(</span><span class="n">_</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]</span>
<span class="p">)</span><span class="o">.</span><span class="n">do</span><span class="p">(</span>
    <span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="s2">"</span><span class="si">{:0&gt;4}</span><span class="s2">"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
<span class="p">))</span>
<span class="c1"># ['0001', '0010', '0011', '0100']</span>
</code></pre></div><h2>内置类型的方法注册</h2><p data-pid="2PtXtyue">下面我们逆向分析一下代码的调用逻辑。首先注册方法的过程和前文提到的略有不同，之前我们是把一个函数作为value写进list的__dict__字典中的，但这里传入的是一个自定义的类，还加了一层property函数作为wrapper。我们先不用管传入类的用意，毕竟这里作为list属性字典的值，传入什么都可以，我们需要理解一下的是property函数。</p><p data-pid="U8XydiVa"><b>Property的新用法  </b>张风闲的文章 <a href="http://link.zhihu.com/?target=https%3A//www.cnblogs.com/zhangfengxian/p/10199935.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">Python中的property属性</a> 已经将传统用法讲解的十分细致了，作为Python高级语法，它无论是作为装饰器还是用作函数，大致思想都是为类的属性的读写访问添加一个setter层，这是一种常用的设计模式，可以缓冲用户的访问并添加边界检查、权限控制等逻辑，但同时对于用户又是透明的。本文用法更类似于函数，虽然property其实是个内置类：</p><div class="highlight"><pre><code class="language-python"><span></span><span class="c1"># builtins.py class property(object):</span>
<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fget</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fdel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> <span class="k">pass</span>

<span class="c1"># fget: 方法名，调用 对象.属性 时自动触发执行方法</span>
<span class="c1"># fset: 方法名，调用 对象.属性 ＝ XXX 时自动触发执行方法</span>
<span class="c1"># fdel: 方法名，调用 del 对象.属性 时自动触发执行方法</span>
<span class="c1">#  doc: 字符串，调用 对象.属性.doc，此参数是该属性的描述信息</span>
</code></pre></div><p data-pid="zKDEoRFi">本文的property用法很特殊，它没有出现在类里，其传入的参数只有一个，是个类名。经过实验我发现，实际上property包装的意义在于调用该属性时可以<b>自动实例化对应的类</b>，也就是调用其__init__方法，这样看来foreach在这里应该是作为fget参数传入的。</p><h2>foreach类的内部机制</h2><p data-pid="2CKpAcyq">接下来观察foreach类内部的机制。list.foreach自动调用其构造方法，构造方法的参数为iterator，实际上就是将list本身传入了，这里可以参考前文修改内置类中的用法：</p><div class="highlight"><pre><code class="language-python"><span></span><span class="nd">@sign</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="s1">'mean'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="n">l</span><span class="p">):</span> <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
</code></pre></div><p data-pid="Hz6HMO-u">同理，这里的<code>l</code>实际上就是list本身，可以认为它对应的就是list.*时传入的那个self参数。所以foreach的构造方法建立了一个列表内容的引用：self.iterator。观察__getattribute__方法。</p><p data-pid="EDxCID9S"><b>__getattribute__方法  </b>定义了外部在访问类的属性时做出的反应，更严谨地说是对属性访问运算符<code>.</code>的重载，因为其参数key未必是类中定义好的属性。为了防止无限递归，我们需要首先将类内定义过的属性排除在外，转发key值去调用重载前的父类object的方法。然后我们看到对于其他的key，它返回的是mapper类的一个实例。</p><p data-pid="hXOfqdsh">由于作者写这篇代码的时候用的还是Python2.x，其中还有经典类和新式类的区分，可以参考<a href="http://link.zhihu.com/?target=https%3A//blog.csdn.net/u010066807/article/details/46896835" class=" wrap external" target="_blank" rel="nofollow noreferrer">新式类和经典类的属性区别</a>和<a href="https://zhuanlan.zhihu.com/p/98343859" class="internal" target="_blank">两者的方法搜索策略差异</a>。在Python3.x中默认继承object，所以我们也可以去掉类定义中的继承，在这里使用super.*调用父类方法。接下来观察foreach的__iter__方法。</p><p data-pid="shRE0xZe"><b>__iter__方法</b>  传统是用来定义迭代器，但这里使用yield方法定义了一个生成器，也不是不可以。它对刚刚传入的列表进行顺序遍历，然后依次抛出每个元素。不熟悉生成器和迭代器原理的可以随便找一篇介绍，比如 <a href="http://link.zhihu.com/?target=https%3A//www.runoob.com/python3/python3-iterator-generator.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">Python3 迭代器与生成器 | 菜鸟教程</a>。这个方法使得foreach对象可迭代，我们可以通过类似<code>list([1, 2, 3].foreach)</code>的方法输出结果，或者使用for in语句和列表推导式输出结果。</p><h2>mapper类的内部机制</h2><p data-pid="ixYA2XYf">从上文的分析中我们得出<code>list(['1','2','3','4'].foreach.int</code>调用返回的实际上是<code>mapper(['1', '2', '3', '4'], 'int')</code>，下面继续观察mapper类的构造函数。 </p><p data-pid="6BRWJLab">在__init__函数中，mapper对传入的列表和key值建立了引用，同时创建了self.fn这个属性。它其实是mapper定义的对列表中每个元素执行的一个函数。这里默认这个函数是返回元素的key属性，即<code>getattr(o, key, None)</code>的含义是返回o.key，如果属性不存在，就返回默认值None。</p><p data-pid="4BM2YoQf"><b>__getattribute__方法</b>  首先同样排除掉类中定义的属性以避免死循环，然后对于未定义的key，返回一个新的mapper方法，但这时传入的iterator不再是列表，而是当前的mapper对象本身的引用self。这个实现有点函数式编程的curry化的意思，也和JQuery中的诸多方法相似，最常见的例子还是C++中重载左移运算符实现级联输出的方法：</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">ostream</span> <span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">Complex</span> <span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">real</span> <span class="o">&lt;&lt;</span> <span class="s">"+"</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">imag</span> <span class="o">&lt;&lt;</span> <span class="s">"i"</span><span class="p">;</span> <span class="c1">// 以"a+bi"的形式输出</span>
    <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p data-pid="wAUCcmnL">对象的方法操作完成后返回对自身的引用，就可以级联地调用方法了。由于本文中方法调用直接要传递返回值，不能像这段代码这样直接返回引用，而是返回一个以自身引用为参数构造的新的类的实例。这就是最上面例子中，foreach可以调用完int()又调用两次do()的原因。</p><p data-pid="Yw7Dyf-p"><b>__iter__方法</b>  mapper同样实现了一个生成器，以和foreach类保持统一。区别是，它循环遍历iterator中存储的可迭代对象，使用self.fn储存的函数分别作用于每个元素。这里仔细思考一下，其实是一个绝妙的递归，生成器嵌套的递归。例如<code>[1,2,3].foreach.int().str()</code>这段调用，其等价于 </p><div class="highlight"><pre><code class="language-python"><span></span><span class="n">mapper</span><span class="p">(</span><span class="n">mapper</span><span class="p">(</span><span class="n">foreach</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]),</span> <span class="s1">'int'</span><span class="p">),</span> <span class="s1">'str'</span><span class="p">)</span>
</code></pre></div><p data-pid="aaZL85YA">那么当我们使用list()去收割最外层mapper对象的生成器时，对于每个元素它会调用自己的fn函数，但它首先要递归地去遍历内层mapper的生成器，内层mapper再去遍历foreach的生成器。foreach将列表原样返回给内层mapper，后者执行int函数，结果传递给外层mapper，然后外层mapper执行str函数得到结果。</p><p data-pid="IAkEDHGM"><b>__call__方法</b>  使得mapper类的实例能够像函数一样使用。<code>[1,2,3].foreach.int</code>返回的是一个mapper对象，后面加上括号就可以直接执行它的__call__方法。我们使用*args和**kwargs接收不定长参数，并根据key值的不同构造不同的fn函数。如果key值为'do'，我们将do括号内的第一个参数直接作为fn函数，当然为了健壮性，如果do没有参数，就将可迭代对象的元素原样返回，相当于do nothing。当key值为其他，比如‘int’、‘str’等，我们就在可迭代对象的内置方法以及Python全局的内置方法中搜索是否有匹配。</p><div class="highlight"><pre><code class="language-python"><span></span><span class="k">lambda</span> <span class="n">o</span><span class="p">:</span> <span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
          <span class="ow">or</span> <span class="n">unguido</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">))(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</code></pre></div><p data-pid="FKOVsoQU">这段代码的意思是，寻找元素o的key方法或属性，如果不存在则得到None，又根据逻辑判断的短路原则，当且仅当前项为False时继续执行or后面的内容，即unguido方法。我没猜到作者为什么给它起这么个名字，只知道Guido是Python之父，加个否定前缀不知道想否定谁。在unguido函数中同样使用了or的短路：</p><div class="highlight"><pre><code class="language-python"><span></span><span class="k">def</span> <span class="nf">unguido</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
        <span class="nb">getattr</span><span class="p">(</span><span class="n">__builtins__</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="ow">or</span> <span class="n">die</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">),</span>
        <span class="bp">self</span><span class="p">)</span>
</code></pre></div><p data-pid="SbS-I1n-">partial也是Python高级语法中很有趣的函数，其第一个参数是一个函数<code>f</code>，后面的参数如果是位置参数<code>P</code>，则依次将<code>f</code>的各个参数固定为<code>p1...pn</code>，如果后面的参数是关键字参数，则将关键字对应的参数固定下来。unguido这里将函数的第一个参数固定为self，也就是上文提到的lamda定义中的元素o。如果去掉partial的装饰，前面就应改成 </p><div class="highlight"><pre><code class="language-python"><span></span><span class="n">unguido</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">))(</span><span class="n">o</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</code></pre></div><p data-pid="GGhZcZYa">这里的or判断逻辑的意思是，先从__builtins__中寻找方法key，如果没有，再从operator库中寻找，如果仍然没有，就抛出KeyError的错误。实际上，想要效果更好，还应该考虑所有其他可用的函数，即从<code>from XXX import *</code>得到的函数。可以在调用die前面添加这句话</p><div class="highlight"><pre><code class="language-python"><span></span><span class="ow">or</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="n">callable</span><span class="p">(</span><span class="n">_</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">locals</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</code></pre></div><h2>程序效果演示</h2><p data-pid="kGkPlye6">该方法不仅可以修改内置类，事实上修改一切类都是可能的，比如Numpy的ndarray</p><div class="highlight"><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="s1">'foreach'</span><span class="p">)(</span><span class="nb">property</span><span class="p">(</span><span class="n">foreach</span><span class="p">))</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">foreach</span><span class="o">.</span><span class="n">do</span><span class="p">(</span>
    <span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="n">_</span>
        <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="o">/</span> <span class="n">_</span>
        <span class="ow">or</span> <span class="mi">1</span>
<span class="p">)))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div><p data-pid="mU-cKZwF">这里我们使用清晰明了的定义，画出震荡函数</p><p data-pid="m7yYz1cM"><img src="https://www.zhihu.com/equation?tex=y%3D%5Cleft%5C%7B+%5Cbegin%7Baligned%7D+%5Cfrac%7B%5Csin%28x%29%7D%7Bx%7D%2C+%5Cquad+x%5Cneq0%5C%5C+1%2C%5Cquad+x%3D0+%5Cend%7Baligned%7D+%5Cright.+%5C%5C" alt="y=\left\{ \begin{aligned} \frac{\sin(x)}{x}, \quad x\neq0\\ 1,\quad x=0 \end{aligned} \right. \\" eeimg="1"> </p><p data-pid="MDDdwUYY">的曲线图</p><figure data-size="normal"><noscript><img src="https://pica.zhimg.com/v2-6fca4019445325dc80f3b15ddd782065_720w.jpg?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="2880" data-rawheight="1622" class="origin_image zh-lightbox-thumb" width="2880" data-original="https://picx.zhimg.com/v2-6fca4019445325dc80f3b15ddd782065_720w.jpg?source=d16d100b"></noscript><img src="data:image/svg+xml;utf8,&lt;svg%20xmlns='http://www.w3.org/2000/svg'%20width='2880'%20height='1622'&gt;&lt;/svg&gt;" data-caption="" data-size="normal" data-rawwidth="2880" data-rawheight="1622" class="origin_image zh-lightbox-thumb lazy" width="2880" data-original="https://picx.zhimg.com/v2-6fca4019445325dc80f3b15ddd782065_720w.jpg?source=d16d100b" data-actualsrc="https://pica.zhimg.com/v2-6fca4019445325dc80f3b15ddd782065_720w.jpg?source=d16d100b"></figure><p data-pid="V6wQLx2r">虽然Numpy自带了更简洁和高效的写法，本文只是提供另一种思路的演示。我相信这个思路在某些场合能够体现出它的优越性~</p>