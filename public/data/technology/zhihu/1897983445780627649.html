<p data-pid="NnORtwcs">本文将探讨大模型推理加速领域的一个新兴研究方向：Prefilling/Decoding 分离技术。受限于文章篇幅，本次讨论将聚焦于该领域的研究动机，主要基于 Roofline 工具展开理论分析，并介绍 DistServe 论文的关键实验发现。具体的解决方案与优化策略将在后续系列文章中进行深入探讨。</p><h2>问题背景</h2><p data-pid="yHp8dnzl">大语言模型目前常用 decoder-only 架构，推理过程在逻辑上可分为两个阶段：​<b>​</b>Prefilling（预填充阶段）<b>​</b>​和 Decoding（​解码阶段）​​。其中，Prefilling <b>​</b>​并行处理所有输入 token（包括 RAG 检索到的文档片段、System Prompt 和 User Prompt 等），存储计算得到的 Key-Value 激活值（即 KV Cache）并生成首个输出 token。​<b>​</b>Decoding 则利用 KV Cache 自回归地（上一位置的输出作为下一位置的输入）生成新的 token，并将计算产生的新 KV 追加到 Cache 中。</p><p data-pid="8ihumxTC">Prefilling 阶段主要优化从请求输入到生成首个 token 的时间延迟（Time To First Token, TTFT），而 Decoding 阶段则着重优化连续 token 之间的生成间隔（Time Per Output Token, TPOT）。以对话系统为例，较低的 TTFT 能确保快速响应，而 TPOT 只需略高于人类阅读速度即可。然而，当这两个过程在计算设备上并行执行时，往往难以同时满足两者的性能需求。</p><p data-pid="MebkY2dV"><b>Prefilling 阶段属于计算密集型（compute-bound）任务，而 Decoding 阶段则呈现访存密集型（memory-bound）特征。</b>这种计算特性的差异导致：在边缘设备等计算能力受限的环境中，Prefilling 性能会受制于硬件算力；而在配备 DGX/HGX 等高性能计算单元的云端服务器上执行 Decoding 时，则会造成计算资源利用率低下。值得注意的是，增大 batch size 虽能有效提升 Decoding 阶段的访存效率进而提高吞吐量，但对 Prefilling 阶段的性能提升效果有限，这进一步印证了两个阶段需要采用差异化的优化策略。</p><p data-pid="oPZ8BnG6">这个关于 bound 的结论是如何得到的呢？</p><h2>理论分析</h2><p data-pid="m-NOHrXU">下面，我们用 Roofline Model<sup data-text="Roofline: An Insightful Visual Performance Model for Floating-Point Programs and Multicore Architectures" data-url="https://people.eecs.berkeley.edu/~kubitron/cs252/handouts/papers/RooflineVyNoYellow.pdf" data-draft-node="inline" data-draft-type="reference" data-numero="1">[1]</sup>给出一个粗糙的定量分析：定义 <img src="https://www.zhihu.com/equation?tex=%5Cpi" alt="\pi" eeimg="1"> 和 <img src="https://www.zhihu.com/equation?tex=%5Cbeta" alt="\beta" eeimg="1"> 分别为计算设备的最大计算能力（FLOP/s）和最大存储传输带宽（Byte/s），定义推理过程的计算量除以访存量为计算强度 <img src="https://www.zhihu.com/equation?tex=I" alt="I" eeimg="1"> （FLOP/Byte）。当计算强度低于 <img src="https://www.zhihu.com/equation?tex=%5Cpi%2F%5Cbeta" alt="\pi/\beta" eeimg="1"> 时，性能瓶颈主要来自于访存能力，反之来自于计算能力。Roofline Model 不是用来衡量模型的效率，而是衡量模型独占设备时对资源的利用率，这将指导模型选用多强的设备，设备支撑多大的模型，避免出现“大炮打蚊子”的资源浪费。</p><h3>Prefilling 阶段的计算强度</h3><p data-pid="Ywzq7sps">对于 Attention 层，假设输入 batch size 为 <img src="https://www.zhihu.com/equation?tex=b" alt="b" eeimg="1">，序列长度为 <img src="https://www.zhihu.com/equation?tex=n" alt="n" eeimg="1">，模型隐层维度为 <img src="https://www.zhihu.com/equation?tex=d" alt="d" eeimg="1">，注意力头数为 <img src="https://www.zhihu.com/equation?tex=m" alt="m" eeimg="1">，GQA 的组数为 <img src="https://www.zhihu.com/equation?tex=g" alt="g" eeimg="1"> 。那么，计算 <img src="https://www.zhihu.com/equation?tex=Q" alt="Q" eeimg="1">、<img src="https://www.zhihu.com/equation?tex=K" alt="K" eeimg="1">、<img src="https://www.zhihu.com/equation?tex=V" alt="V" eeimg="1"> 矩阵的时间复杂度为 <img src="https://www.zhihu.com/equation?tex=3bnd%5E2" alt="3bnd^2" eeimg="1">，对 <img src="https://www.zhihu.com/equation?tex=Q" alt="Q" eeimg="1"> 和 <img src="https://www.zhihu.com/equation?tex=K" alt="K" eeimg="1"> 进行 RoPE 编码需要 <img src="https://www.zhihu.com/equation?tex=bnd%2Bbnd%2Fg" alt="bnd+bnd/g" eeimg="1"> ，计算 <img src="https://www.zhihu.com/equation?tex=QK%5E%5Ctop" alt="QK^\top" eeimg="1">需要 <img src="https://www.zhihu.com/equation?tex=bn%5E2d" alt="bn^2d" eeimg="1">，softmax 需要 <img src="https://www.zhihu.com/equation?tex=3bmn%5E2" alt="3bmn^2" eeimg="1">，其结果与 <img src="https://www.zhihu.com/equation?tex=V" alt="V" eeimg="1"> 相乘需要 <img src="https://www.zhihu.com/equation?tex=bn%5E2d" alt="bn^2d" eeimg="1">，再乘以一个输出投影矩阵需要 <img src="https://www.zhihu.com/equation?tex=bnd%5E2" alt="bnd^2" eeimg="1"> 。而对于空间复杂度，存储模型参数需要 <img src="https://www.zhihu.com/equation?tex=2d%5E2%2B2d%5E2%2Fg" alt="2d^2+2d^2/g" eeimg="1"> ，存储中间激活需要 <img src="https://www.zhihu.com/equation?tex=3bnd%2Bbmn%5E2" alt="3bnd+bmn^2" eeimg="1">。可以得到 Prefilling 阶段的 Attention 的计算强度为 <img src="https://www.zhihu.com/equation?tex=%5Cfrac%7Bbnd%284d%2B1%2B1%2Fg%2B2n%29%2B3bmn%5E2%7D%7B2d%5E2%2B2d%5E2%2Fg%2Bbn%283d%2Bmn%29%7D" alt="\frac{bnd(4d+1+1/g+2n)+3bmn^2}{2d^2+2d^2/g+bn(3d+mn)}" eeimg="1"> 。</p><p data-pid="QVad4ad0">对于 FFN 层，假设升维后的维度为 <img src="https://www.zhihu.com/equation?tex=4d" alt="4d" eeimg="1">。那么，升维过程的时间复杂度为 <img src="https://www.zhihu.com/equation?tex=8bnd%5E2" alt="8bnd^2" eeimg="1">，Swish 激活函数需要 <img src="https://www.zhihu.com/equation?tex=8bnd" alt="8bnd" eeimg="1">，Hadamard 积需要 <img src="https://www.zhihu.com/equation?tex=4bnd" alt="4bnd" eeimg="1"> ，降维过程需要 <img src="https://www.zhihu.com/equation?tex=4bnd%5E2" alt="4bnd^2" eeimg="1"> 。对于空间复杂度，存储模型参数需要 <img src="https://www.zhihu.com/equation?tex=12d%5E2" alt="12d^2" eeimg="1">，存储中间激活需要 <img src="https://www.zhihu.com/equation?tex=8bnd" alt="8bnd" eeimg="1">。可以得到 Prefilling 阶段的 FFN 的计算强度为 <img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B3bn%28d%2B1%29%7D%7B3d%2B2bn%7D" alt="\frac{3bn(d+1)}{3d+2bn}" eeimg="1"> 。</p><h3>Decoding 阶段的计算强度</h3><p data-pid="8l_6EqfU">当计算到第 <img src="https://www.zhihu.com/equation?tex=t%2B1" alt="t+1" eeimg="1"> 个输出 token 时：</p><p data-pid="CusdgOy8">对于 Attention 层，假设输入 batch size 为 <img src="https://www.zhihu.com/equation?tex=b" alt="b" eeimg="1">，模型隐层维度为 <img src="https://www.zhihu.com/equation?tex=d" alt="d" eeimg="1">，注意力头数为 <img src="https://www.zhihu.com/equation?tex=m" alt="m" eeimg="1">，GQA 的组数为 <img src="https://www.zhihu.com/equation?tex=g" alt="g" eeimg="1"> 。计算 <img src="https://www.zhihu.com/equation?tex=Q" alt="Q" eeimg="1"> 及其 RoPE 编码的时间复杂度为 <img src="https://www.zhihu.com/equation?tex=bd%5E2%2Bbd" alt="bd^2+bd" eeimg="1"> ，<img src="https://www.zhihu.com/equation?tex=K" alt="K" eeimg="1">、<img src="https://www.zhihu.com/equation?tex=V" alt="V" eeimg="1"> 矩阵直接从 cache 中获取，无需计算。计算 <img src="https://www.zhihu.com/equation?tex=QK%5E%5Ctop" alt="QK^\top" eeimg="1">需要 <img src="https://www.zhihu.com/equation?tex=b%28n%2Bt%29d" alt="b(n+t)d" eeimg="1">，softmax 需要 <img src="https://www.zhihu.com/equation?tex=3bm%28n%2Bt%29" alt="3bm(n+t)" eeimg="1">，其结果与 <img src="https://www.zhihu.com/equation?tex=V" alt="V" eeimg="1"> 相乘需要 <img src="https://www.zhihu.com/equation?tex=b%28n%2Bt%29d" alt="b(n+t)d" eeimg="1">，再乘以一个输出投影矩阵需要 <img src="https://www.zhihu.com/equation?tex=bd%5E2" alt="bd^2" eeimg="1"> 。而对于空间复杂度，存储模型参数需要 <img src="https://www.zhihu.com/equation?tex=2d%5E2%2B2d%5E2%2Fg" alt="2d^2+2d^2/g" eeimg="1"> ，存储中间激活需要 <img src="https://www.zhihu.com/equation?tex=bd%2B2b%28n%2Bt%29d%2Bbm%28n%2Bt%29" alt="bd+2b(n+t)d+bm(n+t)" eeimg="1">。可以得到 Decoding 阶段的 Attention 的计算强度为 <img src="https://www.zhihu.com/equation?tex=%5Cfrac%7Bb%28d%2B%28n%2Bt%29%282d%2B3m%29%2B2d%5E2%29%7D%7B2d%5E2%2B2d%5E2%2Fg%2Bbd%2Bb%28n%2Bt%29%282d%2Bm%29%7D" alt="\frac{b(d+(n+t)(2d+3m)+2d^2)}{2d^2+2d^2/g+bd+b(n+t)(2d+m)}" eeimg="1"> 。</p><p data-pid="P0cgx20H">对于 FFN 层，假设升维后的维度为 <img src="https://www.zhihu.com/equation?tex=4d" alt="4d" eeimg="1">。那么，升维过程的时间复杂度为 <img src="https://www.zhihu.com/equation?tex=8bd%5E2" alt="8bd^2" eeimg="1">，Swish 激活函数需要 <img src="https://www.zhihu.com/equation?tex=8bd" alt="8bd" eeimg="1">，Hadamard 积需要 <img src="https://www.zhihu.com/equation?tex=4bd" alt="4bd" eeimg="1"> ，降维过程需要 <img src="https://www.zhihu.com/equation?tex=4bd%5E2" alt="4bd^2" eeimg="1"> 。对于空间复杂度，存储模型参数需要 <img src="https://www.zhihu.com/equation?tex=12d%5E2" alt="12d^2" eeimg="1">，存储中间激活需要 <img src="https://www.zhihu.com/equation?tex=8bd" alt="8bd" eeimg="1">。可以得到 Decoding 阶段的 FFN 的计算强度为 <img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B3b%28d%2B1%29%7D%7B3d%2B2b%7D" alt="\frac{3b(d+1)}{3d+2b}" eeimg="1"> 。</p><h3>计算强度对比分析</h3><p data-pid="y1D2OG_3">对于 FFN 层，易得 <img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B3b%28d%2B1%29%7D%7B3d%2Fn%2B2b%7D%5Cgeq+%5Cfrac%7B3b%28d%2B1%29%7D%7B3d%2B2b%7D" alt="\frac{3b(d+1)}{3d/n+2b}\geq \frac{3b(d+1)}{3d+2b}" eeimg="1">，即 Prefilling 阶段的计算强度更大。在实际推理时，由于显存受限，往往是 <img src="https://www.zhihu.com/equation?tex=d%5Cgg+b" alt="d\gg b" eeimg="1">，而 <img src="https://www.zhihu.com/equation?tex=n" alt="n" eeimg="1"> 通常是 1k 以上的数量级，所以这两个计算强度相差甚远。Attention 层的结果与之类似。为了清晰地对比二者，我们以 LLaMA2-7B 的模型结构为例，考虑 NVIDIA RTX 3090 作为计算设备，绘制 Roofline 图。</p><p data-pid="lO_sF4cO">LLaMA2-7B 共有 <img src="https://www.zhihu.com/equation?tex=m%3D32" alt="m=32" eeimg="1"> 个注意力头，隐层维度 <img src="https://www.zhihu.com/equation?tex=d%3D4096" alt="d=4096" eeimg="1">，使用 MHA 所以 <img src="https://www.zhihu.com/equation?tex=g%3D1" alt="g=1" eeimg="1"><sup data-text="LLaMA 2 Configurations" data-url="https://github.com/huggingface/transformers/blob/main/src/transformers/models/llama/configuration_llama.py" data-draft-node="inline" data-draft-type="reference" data-numero="2">[2]</sup>。考虑 Prefilling 的输入长度为 1k，Decoding 的当前输出 token 为第 1k 个，batch size 为 1（其他参数区别不大）。NVIDIA RTX 3090 的 Float32 理想计算能力大致为 35.58 TFLOPS，HBM（显存）的读写速度平均为 0.936 TB/s<sup data-text="Specs of NVIDIA RTX 3090" data-url="https://gpuspecs.com/card/nvidia-geforce-rtx-3090-24gb" data-draft-node="inline" data-draft-type="reference" data-numero="3">[3]</sup>。Roofline 图如下所示，横纵坐标都是 log scale。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-6ac8c608aa314e89acc492592cc9e701_720w.jpg?source=d16d100b" data-size="normal" data-rawwidth="3000" data-rawheight="1200" class="origin_image zh-lightbox-thumb" width="3000" data-original="https://picx.zhimg.com/v2-6ac8c608aa314e89acc492592cc9e701_720w.jpg?source=d16d100b"></noscript><img src="data:image/svg+xml;utf8,&lt;svg%20xmlns='http://www.w3.org/2000/svg'%20width='3000'%20height='1200'&gt;&lt;/svg&gt;" data-size="normal" data-rawwidth="3000" data-rawheight="1200" class="origin_image zh-lightbox-thumb lazy" width="3000" data-original="https://picx.zhimg.com/v2-6ac8c608aa314e89acc492592cc9e701_720w.jpg?source=d16d100b" data-actualsrc="https://pic1.zhimg.com/v2-6ac8c608aa314e89acc492592cc9e701_720w.jpg?source=d16d100b"><figcaption>LLaMA2-7B 在 NVIDIA RTX 3090 上的 P/D 阶段瓶颈分析</figcaption></figure><p data-pid="kW1TZRpu"><b>显然 Decoding 阶段都落在了 Memory Bound 区域，而 Prefilling 都落在 Compute Bound 区域。</b>这和定性分析的结果是一致的：Decoding 阶段受到自回归逻辑的限制，每次只能计算一个 token，却依赖之前所有的 KV 值；而 Prefilling 过程虽然也要存储所有的 KV，却同时计算了所有输入 token，提高了计算强度。</p><p data-pid="_h6ekfWs">注意这里我们假定的是 SRAM 很小，每次计算都要从 HBM 中加载参数或向 SRAM 写入激活值。同时假定了 HBM 大小不成为瓶颈，一旦其存储大小受限，我们就得考虑将部分参数和激活卸载到 CPU Memory，那么等效的读写带宽就会更小，上图红色线段就会呈现出更小的斜率，从而造成更大面积的 Memory Bound 区域。</p><h2>实验分析</h2><p data-pid="jZRwzPvK"><a href="http://link.zhihu.com/?target=https%3A//www.usenix.org/system/files/osdi24-zhong-yinmin.pdf" class=" wrap external" target="_blank" rel="nofollow noreferrer">DistServe: Disaggregating Prefill and Decoding for Goodput-optimized Large Language Model Serving</a> 是 2024 年发表在 OSDI 上的 P/D 分离的开山之作，在论述分离架构的优势时，直接举了个例子：在 A100/80G 上推理 13B 大模型（batch size 为 512，输出长度为 64），只推理 Prefilling 阶段或只推理 Decoding 阶段时，支持的最高并发请求数量明显优于现有主流推理系统（如 PagedAttention<sup data-text="Efficient Memory Management for Large Language Model Serving with PagedAttention" data-url="https://dl.acm.org/doi/pdf/10.1145/3600006.3613165" data-draft-node="inline" data-draft-type="reference" data-numero="4">[4]</sup>、Orca<sup data-text="ORCA: A Distributed Serving System for Transformer Based Generative Models" data-url="https://www.usenix.org/system/files/osdi22-yu.pdf" data-draft-node="inline" data-draft-type="reference" data-numero="5">[5]</sup>等）。现有系统普遍采用 P/D 一体化设计架构，如 Orca 的 Continuous Batching 技术，为了最大化系统吞吐率，将处于不同推理阶段、不同序列长度和解码位置的请求合并处理。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-8a3d260400f2e0a1dff2ef19b732b8d9_720w.jpg?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="1236" data-rawheight="480" class="origin_image zh-lightbox-thumb" width="1236" data-original="https://pic1.zhimg.com/v2-8a3d260400f2e0a1dff2ef19b732b8d9_720w.jpg?source=d16d100b"></noscript><img src="data:image/svg+xml;utf8,&lt;svg%20xmlns='http://www.w3.org/2000/svg'%20width='1236'%20height='480'&gt;&lt;/svg&gt;" data-caption="" data-size="normal" data-rawwidth="1236" data-rawheight="480" class="origin_image zh-lightbox-thumb lazy" width="1236" data-original="https://pic1.zhimg.com/v2-8a3d260400f2e0a1dff2ef19b732b8d9_720w.jpg?source=d16d100b" data-actualsrc="https://pic1.zhimg.com/v2-8a3d260400f2e0a1dff2ef19b732b8d9_720w.jpg?source=d16d100b"></figure><p data-pid="PKGUMu6r">DistServe 绘制了如左图所示的不同情况下的服务质量曲线。纵坐标 P90 表示 90% 的请求满足服务等级协议（SLA）要求，其中黑色虚线标注了示例 SLA 的具体指标：要求 90% 请求的 TTFT ≤ 0.4s，TPOT ≤ 0.04s。曲线与 SLA 阈值的交点横坐标表征了系统在保证服务质量前提下的最大并发处理能力。</p><p data-pid="hxqSBNAN">实验数据表明，当计算设备专用于 Prefilling 或 Decoding 时，系统支持的并发请求量显著提升，这意味着 MaaS（Model as a Service）提供商可以借此优化资源配置，显著降低运营成本。</p><p data-pid="ayS_mfXX">右图进一步探讨了在批量进行的 Decoding 中加入一条 Prefilling 请求造成的影响。Prefilling 因为 Decoding batch size 从 0 逐渐增加而总的延迟上升，decoding 也因为加入了一条 Prefilling 从橘色线跳到了蓝色线。当输入长度从 128（当前右图的设定）增长到 1024 时，Decoding 过程的延迟上升更加明显。</p><h2>研究展望</h2><p data-pid="X86LsvlD">以上分析并不能说明 P/D 分离一定好，但至少给出了一个愿景。但在实际应用中，Prefilling 设备和 Decoding 设备之间的 KV Cache 传输开销可能造成很大的 overhead。另外，像后面 Kimi 的 Mooncake<sup data-text="Mooncake: A KVCache-centric Disaggregated Architecture for LLM Serving" data-url="https://arxiv.org/pdf/2407.00079" data-draft-node="inline" data-draft-type="reference" data-numero="6">[6]</sup>讨论的那样，这种 P/D 分离架构主要在长序列的情况下有效。如果在本文上面给出的理论分析中代入 <img src="https://www.zhihu.com/equation?tex=n%3D64" alt="n=64" eeimg="1">，并将计算设备换成 A100<sup data-text="Specs of NVIDIA A100 Tensor Core GPU" data-url="https://www.nvidia.com/content/dam/en-zz/Solutions/Data-Center/a100/pdf/nvidia-a100-datasheet-us-nvidia-1758950-r4-web.pdf" data-draft-node="inline" data-draft-type="reference" data-numero="7">[7]</sup>，就会发现两个阶段的计算强度都落入了 Memory Bound，这时可能需要增大 batch size 来进行补偿。</p><p data-pid="KP-qm6-X">有些人质疑 P/D 分离，认为大模型的场景也不都是长序列的。但因为我本身更关注 RAG，它依赖来自文档库或者搜索引擎的长文本做 in-context 增强，所以在其位、谋其政。我觉得 P/D 分离对于 RAG 来说是好事，甚至可以把 Retrieval 和 Prefilling 绑定在一起，把 Decoding 解耦出去，产生专门做 KDN（Knowledge Delivery Network<sup data-text="Do Large Language Models Need a Content Delivery Network?" data-url="https://arxiv.org/pdf/2409.13761" data-draft-node="inline" data-draft-type="reference" data-numero="8">[8]</sup>，类似 CDN）服务的公司。</p><p data-pid="y1HAuDfG">这些 KDN 公司可以为企业和高校做 RAG 解决方案，把专用的、隐私的文档以及常用的互联网内容进行切片、索引和 Prefill，用户在手机或者 PC 上只需要连入企业网、校园网，就可以即插即用地访问这些知识。在高性能服务器上统一 Prefill，不断同步到分布式的存储节点上，然后多客户端检索复用，这样既避免在弱设备上 Prefill，又节省了服务器 Decoding 的成本（成本卸载到用户侧）。那些 MaaS 公司也可以从这种 KDN 上订阅服务，这样自己只做 Decoding，对用户的服务计费也变得清晰、透明了。</p><p data-pid="Wgj9iH-d">我最近的一篇工作（<a href="http://link.zhihu.com/?target=https%3A//arxiv.org/pdf/2504.11197" class=" wrap external" target="_blank" rel="nofollow noreferrer">Efficient Distributed Retrieval-Augmented Generation for Enhancing Language Model Performance</a>）对这种端云分布式 RAG 架构进行了探讨，之后大概率会沿着这个方向继续前进。</p>