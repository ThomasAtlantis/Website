<p data-pid="-ta_sqQZ">本系列文章长期维护更新，希望Python编程水平逐日精进</p><ul><li data-pid="9FQ915cc"><a href="https://zhuanlan.zhihu.com/p/344907422" class="internal" target="_blank">Python高级编程 | 知识碎片</a></li><li data-pid="lmZIPMay"><a href="https://zhuanlan.zhihu.com/p/345058566" class="internal" target="_blank">Python高级编程 | 奇技淫巧</a></li><li data-pid="IWNJC1sk"><a href="https://zhuanlan.zhihu.com/p/345187339" class="internal" target="_blank">Python高级编程 | 走火入魔</a></li></ul><h2>修改内置类型的属性和方法</h2><p data-pid="T6qy3EX7">在网上闲逛的时候偶然看到StackOverflow上的一个9年前的老帖子：<a href="http://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/6738987/extension-method-for-python-built-in-types" class=" wrap external" target="_blank" rel="nofollow noreferrer">Extension method for python built-in types</a>。修改Python的内置数据类型的属性和方法，我以前也在具体的场景中有过这种念头。但对于我来说这个问题可怕且无解，往往是绕道而行。<b>一方面，其中涉及到的技术必然十分复杂；另一方面，对Python语言本身的破坏，必然严重损害业务逻辑的可读性。</b>如今仔细研究了一下，发现其中不仅具有技术意义，也不乏娱乐效果。发现网上对这个的研究并不多，对其方法的详解更是少之又少，在此做如下总结：</p><a href="https://zhuanlan.zhihu.com/p/345547458" data-draft-node="block" data-draft-type="link-card" data-image="https://picx.zhimg.com/v2-80dc6572c3d85a4e11543a3ae5de1678_qhd.jpg?source=d16d100b" data-image-width="684" data-image-height="425" class="internal">清川：Python修改内置类型的属性和方法</a><h2>为列表添加一个foreach方法</h2><p data-pid="bZmQJYoF">本文是 <a href="https://zhuanlan.zhihu.com/p/345547458" class="internal" target="_blank">Python修改内置类型的属性和方法</a> 的后续，继续讲解前文提到的SO的回答 <a href="http://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/6738987/extension-method-for-python-built-in-types%23answer-15975791" class=" wrap external" target="_blank" rel="nofollow noreferrer">Answer - Extension method for python built-in types</a> 中提供的foreach方法。我做了一些小改进，其中包括调整代码对Python3.x的兼容性以及实现foreach中执行自定义的lambda函数：</p><a href="https://zhuanlan.zhihu.com/p/345554379" data-draft-node="block" data-draft-type="link-card" data-image="https://picx.zhimg.com/v2-f2e7fa0dfe825f7d51bee4124687894e_qhd.jpg?source=d16d100b" data-image-width="1848" data-image-height="568" class="internal">清川：Python为列表添加一个foreach方法</a><h2>函数的curry化</h2><p data-pid="qDT8XJWr">函数式编程curry的概念： 只传递给函数一部分参数来调用函数，然后返回一个函数去处理剩下的参数。我们可以一次性的调用函数，也可以每次只传入一个参数分多次调用。curry化把函数的层层调用和封装，变成了状态的转换。函数每调用一次，生成一个新的函数，即相当于迁移至了一个新的状态上。于是程序代码更加接近状态机，也会有助于程序结构的梳理。</p><div class="highlight"><pre><code class="language-python"><span></span><span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">getfullargspec</span> <span class="k">as</span> <span class="n">spec</span>

<span class="k">class</span> <span class="nc">curry</span><span class="p">:</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spec</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args_now</span> <span class="o">=</span> <span class="p">[]</span>
        
    <span class="k">def</span> <span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args_now</span> <span class="o">+=</span> <span class="n">args</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args_now</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">args_len</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args_now</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">args_now</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args_now</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">())</span>

<span class="nd">@curry</span>
<span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">sum</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">])</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>

<span class="n">mean</span> <span class="o">|</span><span class="mi">10</span><span class="o">|</span><span class="mi">11</span><span class="o">|</span><span class="mi">12</span><span class="o">|</span><span class="mi">13</span>  <span class="c1"># 11.5</span>
</code></pre></div><p data-pid="hm74g-Eo">这里仅当传入mean的参数积累到4个时执行函数。参考了这篇回答：<a href="https://www.zhihu.com/question/431725755/answer/1592193887" class="internal" target="_blank">Python 语言有什么奇技淫巧吗？</a>但后来反思一下，答主的代码写的既啰嗦又无用，这里稍稍改了一下，勉强收录在本文中。inspect.getfullargspec(function).args可以获取函数定义的所有形参，倒是值得记住。</p><h2>模仿C++输出</h2><p data-pid="nSddHWyg">这里也相当于编写了一个curry式的函数，主要为了记录元类编程type的用法小例子。</p><div class="highlight"><pre><code class="language-python"><span></span><span class="c1"># method 1</span>
<span class="k">class</span> <span class="nc">Cout</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__lshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">""</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

<span class="c1"># method 2</span>
<span class="n">cout</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="s1">'_'</span><span class="p">,</span> <span class="p">(),</span> <span class="p">{</span>
    <span class="s2">"__lshift__"</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="o">*</span><span class="n">o</span><span class="p">:</span> <span class="p">[</span>
        <span class="nb">print</span><span class="p">(</span><span class="o">*</span><span class="n">o</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">" "</span><span class="p">),</span> <span class="n">s</span>
    <span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">})()</span>

<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="s2">"hello world"</span>
</code></pre></div><h2>模仿命令行管道</h2><p data-pid="EgSGF1VS">这段代码来自回答<a href="https://www.zhihu.com/question/431725755/answer/1681661444" class="internal" target="_blank">Python 语言有什么奇技淫巧吗？</a>，是我见过的最优雅的代码之一</p><div class="highlight"><pre><code class="language-python"><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="n">F</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="s1">'_'</span><span class="p">,</span> <span class="p">(</span><span class="n">partial</span><span class="p">,),</span> <span class="p">{</span>
    <span class="s1">'__ror__'</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">,</span><span class="n">o</span><span class="p">:</span>
        <span class="n">s</span><span class="p">(</span><span class="o">*</span><span class="n">o</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">else</span> <span class="n">s</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
<span class="p">})</span>

<span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">|</span> <span class="n">F</span><span class="p">(</span><span class="nb">filter</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="n">F</span><span class="p">(</span><span class="nb">sum</span><span class="p">)</span>  <span class="c1"># 25</span>
</code></pre></div><p data-pid="GbQ6y1UK">以上的调用实际上相当于</p><div class="highlight"><pre><code class="language-python"><span></span><span class="n">F</span><span class="p">(</span><span class="nb">sum</span><span class="p">)</span><span class="o">.</span><span class="fm">__ror__</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="nb">filter</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="fm">__ror__</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)))</span>
</code></pre></div><p data-pid="Gb6MVO4W">F是使用元类type创建的类，它继承了partial类。在实例化的时候，如果括号内只有一个参数，则F的__call__方法就调用这个参数所代表的函数，那么F的实例就可以等价于这个函数来使用。如果括号内有多个参数，则第一个参数代表的函数在__call__调用时执行，其他参数将作为这个函数的参数固定下来。举几个例子：</p><div class="highlight"><pre><code class="language-python"><span></span><span class="n">F</span><span class="p">(</span><span class="nb">sum</span><span class="p">)([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>  <span class="c1"># 6</span>
<span class="n">F</span><span class="p">(</span><span class="nb">print</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">" "</span><span class="p">)(</span><span class="o">*</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>  <span class="c1"># 1 2 3</span>
<span class="nb">list</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span>  <span class="c1"># 2, 3, 4</span>
</code></pre></div><p data-pid="_l9ybLUw">F重载了右侧或运算的函数__ror__，其第一个参数s就是本身的引用self，后面的o则是运算真正的输入。如果o是元组则对其进行解包，否则直接传入函数执行。</p><h2>模仿判断和循环的end</h2><p data-pid="gaTMDxu1">因为我们知道Ellipsis常量可以用来替代pass，具有很好的表意作用。这里在全局的内建方法与属性表中加入end，让它作为无意义的占位，也可以提高代码可读性，尤其是语句块的内容非常长，常常找不到层次关系时可以使用。</p><div class="highlight"><pre><code class="language-python"><span></span><span class="n">__builtins__</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="o">...</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">" "</span><span class="p">)</span>
<span class="n">end</span>
</code></pre></div><p data-pid="cd9CMRVE">除了用来装B以外，你也可以说是在对Pascal、Lua、Julia、Matlab、Fortran等语言致敬</p>