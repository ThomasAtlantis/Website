<h2>写在前面</h2><p data-pid="DRIsZOVI">本文是一篇读书笔记，<b>不会对函数式编程进行系统地讲解</b>，相反只记录关于Python函数式编程的一些零碎的知识点（我不会的以及我觉得很妙的），另外也会记录一些对于此书写作的评价。大家如果想要系统地学习函数式编程，建议读一读原书：</p><a data-draft-node="block" data-draft-type="mcn-link-card" data-mcn-id="1381969625425608704"></a><p data-pid="hZnutVir">如果遇到不懂的问题，或者觉得很妙而我没体会到的，也可以私信我一起交流。Python高级编程是一系列文章，面向已有一定编程基础但不满足于基础编程的小伙伴，致力于查缺补漏式的讲解网上不太常见的Python知识，将会长期更新，本系列其他文章请见：</p><ul><li data-pid="Bc2LD-go"><a href="https://zhuanlan.zhihu.com/p/344907422" class="internal" target="_blank">Python高级编程 | 知识碎片</a></li><li data-pid="nDunJ2uG"><a href="https://zhuanlan.zhihu.com/p/345058566" class="internal" target="_blank">Python高级编程 | 奇技淫巧</a></li><li data-pid="CCKRO69R"><a href="https://zhuanlan.zhihu.com/p/345187339" class="internal" target="_blank">Python高级编程 | 走火入魔</a></li></ul><h2>第1章 函数式编程概述</h2><ul><li data-pid="aAnUCST9"><b>函数式编程的经典案例：牛顿迭代法求平方根</b></li></ul><div class="highlight"><pre><code class="language-python"><span></span><span class="k">def</span> <span class="nf">next_</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">n</span> <span class="o">/</span> <span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

<span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="k">yield</span> <span class="n">x</span>
    <span class="k">yield from</span> <span class="n">repeat</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">within</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">head_tail</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">iterable</span><span class="p">):</span>
        <span class="n">b</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">e</span><span class="p">:</span> <span class="k">return</span> <span class="n">b</span>
        <span class="k">return</span> <span class="n">head_tail</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">iterable</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">head_tail</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="nb">next</span><span class="p">(</span><span class="n">iterable</span><span class="p">),</span> <span class="n">iterable</span><span class="p">)</span>
</code></pre></div><p data-pid="NgDAP-3_">这个例子举得很好，仔细体会很有感觉。牛顿迭代法，又叫Newton-Raphson迭代法（书中用的是这个名字），迭代公式大致如下：</p><p data-pid="xb6Gh0vL"><img src="https://www.zhihu.com/equation?tex=x%5E%7B%28k%2B1%29%7D%3Dx%5E%7B%28k%29%7D-%5Cfrac%7Bf%28x%5E%7B%28k%29%7D%29%7D%7Bf%5E%5Cprime%28x%5E%7B%28k%29%7D%29%7D%5C%5C" alt="x^{(k+1)}=x^{(k)}-\frac{f(x^{(k)})}{f^\prime(x^{(k)})}\\" eeimg="1"> </p><p data-pid="Z-5upPVb">我们将计算平方根的过程构造为求函数 <img src="https://www.zhihu.com/equation?tex=f%28x%29%3Dx%5E2-n" alt="f(x)=x^2-n" eeimg="1"> 的零点的过程。其中 <img src="https://www.zhihu.com/equation?tex=n" alt="n" eeimg="1"> 表示要开方的数，维护 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"> 储存最终要求的解。那么可以推出上述代码中的next_函数：</p><p data-pid="M4rPTHGm"><img src="https://www.zhihu.com/equation?tex=x%5Cgets+x-%5Cfrac%7Bx%5E2-n%7D%7B2x%7D%3D%5Cfrac%7Bx%2Bn%2Fx%7D%7B2%7D%5C%5C" alt="x\gets x-\frac{x^2-n}{2x}=\frac{x+n/x}{2}\\" eeimg="1"> </p><p data-pid="GsyaIrNo">接下来repeat函数使用递归地方式定义了一个生成器，每次抛出 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"> ，之后从下一次迭代结果的生成器中继续抛出下一步的 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"> 。</p><p data-pid="cb6IS6qk">这里的<b> yield from</b> 就是我想重点记录的碎片，它是Python3.3之后的语法，在生成器的函数定义中与以下啰嗦的写法完全等价：</p><div class="highlight"><pre><code class="language-python"><span></span><span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">repeat</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span> <span class="k">yield</span> <span class="n">v</span>  <span class="c1"># equivalent to `yield from repeat(f, f(x))`</span>
</code></pre></div><p data-pid="oxjjtska">之后 within 函数定义了另一个递归来取出这个生成器中的元素。next_ 函数的定义没有设置结束条件，可以无限生成，而这里的 within 给它设置了一个最小更新阈值 <img src="https://www.zhihu.com/equation?tex=e" alt="e" eeimg="1"> 。这种递归的写法也值得借鉴，在类似C不能嵌套定义函数的编程语言中，往往为了定义递归入口，我们需要写 within 和 head_tail 两个函数。接下来使用匿名函数固定 <img src="https://www.zhihu.com/equation?tex=n%3D2" alt="n=2" eeimg="1"> ，以1为迭代初始值，以1e-6的精度计算 <img src="https://www.zhihu.com/equation?tex=%5Csqrt+2" alt="\sqrt 2" eeimg="1"> 的值：</p><div class="highlight"><pre><code class="language-python"><span></span><span class="nb">print</span><span class="p">(</span><span class="n">within</span><span class="p">(</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">repeat</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">next_</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="mi">1</span><span class="p">)))</span>
<span class="o">------------------------------------------------------</span>
<span class="mf">1.414213562373095</span>
</code></pre></div><p data-pid="Pzpt5RvQ">这种函数式定义的写法是通用的，我们只需要修改传入的 next_ 迭代函数。</p><ul><li data-pid="R7ywQbN_"><b>关于乌龟塔的比喻</b></li></ul><p data-pid="K3TP2ikf">P7使用乌龟塔的比喻来说明计算机的抽象是无穷无尽的，进而划定本书涉及的方面。实际上我并不认为抽象形成的层是无穷无尽的，毕竟计算机体系是有限的。那个佚名发言让我感觉无中生友，有点尴尬也有点好笑。这里也体现了很多外国人写的书废话太多，本来三行重点被写成一篇散文。核心意思就是计算机抽象层很多，本书只讲其中三层。</p><p data-pid="jkFJnTtL">这里科普一下相关的故事仅供娱乐。公认的乌龟驼世界的神话来源于古印度人</p><blockquote data-pid="rebr_vPE">大地是一个隆起的圆盾，由三条大象扛着，这三条大象站在龟背上，而这个龟又是浮游在广阔海洋之中的</blockquote><p data-pid="Xi44DwI1">而乌龟叠乌龟的说法来源于『时间简史』在开篇提到的一个轶事</p><blockquote data-pid="EpVTMlxT">贝特兰·罗素在演讲中描述了地球如何围绕着太阳公转，而太阳又是如何围绕着称之为我们星系的巨大的恒星集团的中心公转。演讲结束之际，坐在房间后排的一位小个老妇人起立说道：「你讲的是一派胡言。实际上，世界是驮在一只巨大乌龟背上的平板。」这位科学家露出高傲的微笑，然后答道：「那么这只乌龟是站在什么上面的呢？」「你很聪明，年轻人，的确很聪明，」老妇人说，「不过，这是一只驮着一只，一直驮下去的乌龟塔啊！」</blockquote><p data-pid="9f3_yGPV">如果去谷歌上搜索Turtle Tower，还会发现它也是一个地名，越南还剑湖中央的龟丘岛上的一座塔。</p><ul><li data-pid="bJxIMw8C"><b>关于EDA领域</b></li></ul><p data-pid="V3OCjNE5">作者说本文的示例大多来自EDA领域。可能我孤陋寡闻，只知道EDA是电子设计自动化（<b>E</b>lectronic <b>D</b>esign <b>A</b>utomation），但本文所说的EDA实际上是指探索性数据分析（<b>E</b>xploratory <b>D</b>ata <b>A</b>nalysis），强烈建议译者能加点儿脚注。探索性数据分析和传统数据分析的区别主要是先分析数据后进行建模，而不是先假设模型再分析效果。可以参考博文<a href="http://link.zhihu.com/?target=https%3A//www.cnblogs.com/HuZihu/p/11146493.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">探索性数据分析（Exploratory Data Analysis，EDA）</a></p><hr><p data-pid="AblQjfiJ">未完待续</p><p></p>