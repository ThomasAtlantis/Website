<p data-pid="gp2K7nP_">自问自答一波，刚刚貌似发现了解决方法：使用unique_ptr就可以了：</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="kt">int</span> <span class="n">cols</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">rows</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">tmp_2</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Element</span> <span class="p">[]</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">rows</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rows</span><span class="p">;</span> <span class="o">++</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tmp_2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">move</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Element</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Element</span><span class="p">[</span><span class="n">cols</span><span class="p">]));</span>
<span class="p">}</span>
</code></pre></div><p data-pid="rHz_R2G6">想要修改元素内容的时候可以直接取地址：</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tmp_2</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
</code></pre></div><p data-pid="XVSlrnCt">然后修改内容即可：</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="n">x</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span>
</code></pre></div><p data-pid="JTX0cOgz">但是仍然不明白题目中描述的指针二次释放是怎么产生的，请各位大佬不吝赐教！</p><p data-pid="-D-rTmDr">这个问题来自最近的编译器开发，为了描述清晰，进行了一定的简化。在LL1语法分析构建LL1分析表的时候，需要创建一个行数为栈顶符总数，列数为当前符总数的二维表，表格内每个元素定义如下：</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="k">struct</span> <span class="n">Analyze_table_item</span><span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">stack_op</span><span class="p">;</span> <span class="c1">// 对分析栈的操作，文法符号的向量，将来逆序压入栈中</span>
    <span class="kt">char</span> <span class="n">read_op</span> <span class="p">{};</span>                   <span class="c1">// 对输入流的控制，'N'表示读下一个token，'P'表示不读</span>
<span class="p">};</span> <span class="c1">// 分析表中的每一项元素</span>
</code></pre></div><p data-pid="6GzYkQn7">然后需要定义一个get_op函数，能够返回某个位置的元素的指针，以进行读写：</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="n">Analyze_table_item</span> <span class="o">*</span> <span class="nf">get_op</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">stack_top</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">current</span><span class="p">);</span>
</code></pre></div><p data-pid="9gLDxQ4_">当然这个场景下讨论这个问题有点儿无聊，因为规范的写法应该定义一个get_op和一个set_op分别进行读和写，就避免了指针的传递。我当时在set_op函数里调用get_op可能只是为了节省代码吧，现在当事人很后悔 ...</p>