<h2>写在前面</h2><p data-pid="Rpi0NnwD">不会吧，不会吧，2021年了不会还有人自己手撸表达式解释器吧？小编教你一个一步到位的方法！哈哈哈哈听说现在写文章都喜欢这么不说人话了=w=</p><p data-pid="UDw6ZOzE">最近有些人问<a href="https://www.zhihu.com/question/486697035" class="internal" target="_blank">如何使用  python 写一个简单的表达式解释器？</a>，我看到下面有答主说，使用eval和exec。当然这种方法仅限于解释Python自己的表达式，而这往往是没有实际意义的。</p><p data-pid="i5nR2xbK">比如我去年的课程里有个小项目，要写一个完整的搜索引擎系统，包括爬虫、建索引、查询和优化（模糊搜索、通配符搜索等），题目给出的要求比较复杂，我需要自己设计一种查询语法。这时我显然不能eval，一是Python表达式不能满足需求，二是这样做会被注入攻击。如果我逐步设计文法、词法分析、语法分析、语义分析，我估计就写不完可以挂科了，这时我在隐秘的角落里发现了这个宝藏库</p><figure data-size="small"><noscript><img src="https://pica.zhimg.com/v2-dbe352c0521b68645cf39ecefe3f550e_720w.jpg?source=d16d100b" data-caption="" data-size="small" data-rawwidth="1014" data-rawheight="922" class="origin_image zh-lightbox-thumb" width="1014" data-original="https://pic1.zhimg.com/v2-dbe352c0521b68645cf39ecefe3f550e_720w.jpg?source=d16d100b"></noscript><img src="data:image/svg+xml;utf8,&lt;svg%20xmlns='http://www.w3.org/2000/svg'%20width='1014'%20height='922'&gt;&lt;/svg&gt;" data-caption="" data-size="small" data-rawwidth="1014" data-rawheight="922" class="origin_image zh-lightbox-thumb lazy" width="1014" data-original="https://pic1.zhimg.com/v2-dbe352c0521b68645cf39ecefe3f550e_720w.jpg?source=d16d100b" data-actualsrc="https://pica.zhimg.com/v2-dbe352c0521b68645cf39ecefe3f550e_720w.jpg?source=d16d100b"></figure><h2>Pyparsing库简介</h2><p data-pid="KKnP_DYG"><a href="http://link.zhihu.com/?target=https%3A//github.com/pyparsing/pyparsing/wiki" class=" wrap external" target="_blank" rel="nofollow noreferrer">Pyparsing库</a>提供了一个解析任意表达式语法的简便方案，日常可以用来代替正则表达式做文本清洗，复杂点我估计也可以构建一个语言的完整编译（我没试过，我瞎说的）。下面摘自它的<a href="http://link.zhihu.com/?target=https%3A//github.com/pyparsing/pyparsing/wiki" class=" wrap external" target="_blank" rel="nofollow noreferrer">GitHub Wiki</a>：</p><blockquote data-pid="9gEZMy-4">Combined with a fear/dismay at using regular expressions, I wanted an object-assembly model for building up parsers. Since then, tools of this style have come to be called PEG's, or<a href="http://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Parsing_expression_grammar" class=" wrap external" target="_blank" rel="nofollow noreferrer">Parsing Expression Grammars</a>. I also related to Python's operator overloading features, and so pyparsing has become an embedded DSL within Python, making heavy use of operators for grammar construction and call syntax for grammar element naming.</blockquote><p data-pid="I7zEomu7">翻译过来就是：「由于使用正则表达式让我恐惧/沮丧，我希望能有一个用于构建解释器的面向对象的实用框架。从那时起，这类工具逐渐被称做PEG（Parsing Expression Grammars，即解析表达式语法）。PyParasing已经成为嵌入在Python语法中的领域专用语言，并且引入了Python的运算符重载特性。通过它，你可以方便地使用运算符进行语法构造，并可以为可调用的语法产生式符号进行命名。」你可以通过pip直接安装它：</p><div class="highlight"><pre><code class="language-bash"><span></span>pip install pyparsing
</code></pre></div><p data-pid="mD1HAeWm">相关链接：<a href="http://link.zhihu.com/?target=https%3A//pypi.org/project/pyparsing/" class=" wrap external" target="_blank" rel="nofollow noreferrer">PyPI主页</a>、<a href="http://link.zhihu.com/?target=https%3A//pyparsing-docs.readthedocs.io/en/latest/" class=" wrap external" target="_blank" rel="nofollow noreferrer">官方文档</a>、<a href="http://link.zhihu.com/?target=https%3A//github.com/pyparsing/pyparsing/wiki" class=" wrap external" target="_blank" rel="nofollow noreferrer">GitHub Wiki</a>、<a href="http://link.zhihu.com/?target=https%3A//github.com/pyparsing/pyparsing" class=" wrap external" target="_blank" rel="nofollow noreferrer">GitHub源码</a>、<a href="http://link.zhihu.com/?target=http%3A//index-of.co.uk/Tutorials/Getting%2520Started%2520with%2520Pyparsing.pdf" class=" wrap external" target="_blank" rel="nofollow noreferrer">英文版简易教程</a></p><h2>举个栗子：搜索引擎查询语法设计</h2><p data-pid="0Tgcpbta">下面我们直接从上述搜索引擎查询语言设计的场景入手，感受一下它的强大。</p><p data-pid="HpRCPfJ_">课程中我的选题是图书搜索引擎，数据来源为<a href="http://link.zhihu.com/?target=https%3A//www.smashwords.com/" class=" wrap external" target="_blank" rel="nofollow noreferrer">smashwords</a>这个网站。图书信息包括很多字段：标题、作者、出版时间、摘要等等。搜索引擎的基本要求是<b>布尔搜索</b>，也就是可以通过与或非来组合条件，常见搜索引擎都有这个支持，比如知网。举个例子，我们要支持以下查询：</p><ul><li data-pid="YFN7OAn_">标题包含A and 作者包含B</li><li data-pid="wnGr8ETb">标题不包含A or 出版时间为C</li></ul><p data-pid="Q-mNxYDw">然后要求模糊搜索，也就是规定两个词在同一文章（或者段落、句子）中同时出现，并且规定它们相隔多少个单词，规定它们的顺序。要求的原文是这么写的：</p><figure data-size="normal"><noscript><img src="https://pica.zhimg.com/v2-c26d6b8c0433afca7f2e06ffdd6b264a_720w.jpg?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="1286" data-rawheight="324" class="origin_image zh-lightbox-thumb" width="1286" data-original="https://pica.zhimg.com/v2-c26d6b8c0433afca7f2e06ffdd6b264a_720w.jpg?source=d16d100b"></noscript><img src="data:image/svg+xml;utf8,&lt;svg%20xmlns='http://www.w3.org/2000/svg'%20width='1286'%20height='324'&gt;&lt;/svg&gt;" data-caption="" data-size="normal" data-rawwidth="1286" data-rawheight="324" class="origin_image zh-lightbox-thumb lazy" width="1286" data-original="https://pica.zhimg.com/v2-c26d6b8c0433afca7f2e06ffdd6b264a_720w.jpg?source=d16d100b" data-actualsrc="https://pica.zhimg.com/v2-c26d6b8c0433afca7f2e06ffdd6b264a_720w.jpg?source=d16d100b"></figure><p data-pid="s7bA5DCQ">我最终设计的语法如下：</p><ul><li data-pid="i1V8R0rg">查询语句以字符串的形式从前端页面传递给后端服务器（Flask）</li><li data-pid="EohJIiJX">每个条件以<code>字段名称+冒号+内容</code>的形式出现。其中字段名称以引号括起，只能为 CONTENT、AUTHOR、TITLE、YEAR、DESCR 其中之一，不区分大小写。内容部分可以是模糊搜索条件或者文本，如果是文本且包含空格则需要使用引号括起。</li><li data-pid="mHhTGWl9">模糊搜索条件以<code>文本1 PRE/位置^间隔 文本2</code>的形式出现，用方括号括起来。其中文本的要求同样为，如果包含空格则需要以引号括起。 位置由以下字母指定：D、P、S，分别代表同一文章、同一段落、同一句子，不区分大小写。PRE代表顺序固定，省略后代表顺序可调换。间隔为整数。<code>^</code>及后面的内容可以省略，代表不指定间隔。如果<code>PRE/</code>后面直接为整数，则默认为同一文章内的间隔。</li><li data-pid="riEjrMqc">查询条件以not修饰则代表排除满足这部分条件的结果。</li><li data-pid="gouB0oT8">不同的查询条件以and、or连接，优先级相同，但低于not修饰。</li><li data-pid="MGCtRXfh">可以使用括号改变条件组合时的优先级。</li></ul><p data-pid="JKlqaCou">用自然语言描述起来很冗长，这显然不是一个正则表达式就能解决的。我们将文法抽象出来：</p><div class="highlight"><pre><code class="language-powershell"><span></span><span class="nv">$word</span>    <span class="p">-&gt;</span> <span class="nv">$word_alphanums</span> <span class="p">|</span> <span class="nv">$quoted_string</span>
<span class="nv">$type</span>    <span class="p">-&gt;</span> <span class="s1">'D'</span> <span class="p">|</span> <span class="s1">'P'</span> <span class="p">|</span> <span class="s1">'S'</span> <span class="p">|</span> <span class="s1">'d'</span> <span class="p">|</span> <span class="s1">'p'</span> <span class="p">|</span> <span class="s1">'s'</span>
<span class="nv">$within</span>  <span class="p">-&gt;</span> <span class="s1">'^'</span> <span class="nv">$word_nums</span> <span class="p">|</span> <span class="nv">$epsilon</span>
<span class="nv">$prox_a</span>  <span class="p">-&gt;</span> <span class="nv">$type</span> <span class="nv">$within</span>
<span class="nv">$prox_b</span>  <span class="p">-&gt;</span> <span class="nv">$word_nums</span> <span class="p">|</span> <span class="nv">$prox_a</span>
<span class="nv">$order</span>   <span class="p">-&gt;</span> <span class="s1">'PRE'</span> <span class="p">|</span> <span class="nv">$epsilon</span>
<span class="nv">$prox</span>    <span class="p">-&gt;</span> <span class="nv">$order</span> <span class="s1">'/'</span> <span class="nv">$prox_b</span>
<span class="nv">$prox_q</span>  <span class="p">-&gt;</span> <span class="s1">'['</span> <span class="nv">$word_alphanums</span> <span class="nv">$prox</span> <span class="nv">$word_alphanums</span> <span class="s1">']'</span>

<span class="nv">$field_1</span>  <span class="p">-&gt;</span> <span class="s1">'CONTENT'</span> <span class="p">|</span> <span class="s1">'content'</span>
<span class="nv">$value_1</span>  <span class="p">-&gt;</span> <span class="nv">$word_alphanums</span> <span class="p">|</span> <span class="nv">$quoted_string</span> <span class="p">|</span> <span class="nv">$prox_q</span>
<span class="nv">$group_1</span>  <span class="p">-&gt;</span> <span class="nv">$field_1</span> <span class="s1">':'</span> <span class="nv">$value_1</span>

<span class="nv">$field_2</span> <span class="p">-&gt;</span> <span class="s1">'AUTHOR'</span> <span class="p">|</span> <span class="s1">'YEAR'</span> <span class="p">|</span> <span class="s1">'author'</span> <span class="p">|</span> <span class="s1">'year'</span> <span class="p">|</span> <span class="s1">'TITLE'</span> <span class="p">|</span> <span class="s1">'DESCR'</span> <span class="p">|</span> <span class="s1">'title'</span> <span class="p">|</span> <span class="s1">'descr'</span>
<span class="nv">$value_2</span> <span class="p">-&gt;</span> <span class="nv">$word</span>
<span class="nv">$group_2</span> <span class="p">-&gt;</span> <span class="nv">$field_2</span> <span class="s1">':'</span> <span class="nv">$value_2</span>

<span class="nv">$query</span>    <span class="p">-&gt;</span> <span class="nv">$group_1</span> <span class="p">|</span> <span class="nv">$group_2</span>
</code></pre></div><p data-pid="FeTmSPaa">这里可能稍稍需要一点儿编译原理的知识，大家可以对照上面的自然语言试着读一下应该是能读懂的。<code>-&gt;</code>代表「推导出」，<code>|</code>代表「或是」。$开头的是非终止符，单引号里的是终止符。word_alphanums指由数字和字母组成的单词，quoted_string指用引号括起来的文本，epsilon代表什么都没有。这时候我们使用pyparsing库，重新以Python的语法在程序中定义以上文法：</p><div class="highlight"><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">pyparsing</span> <span class="k">as</span> <span class="nn">pp</span>


<span class="n">word</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">Word</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">alphanums</span><span class="p">)</span> <span class="o">|</span> <span class="n">pp</span><span class="o">.</span><span class="n">quotedString</span>

<span class="n">prox_a</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">oneOf</span><span class="p">([</span><span class="s1">'D'</span><span class="p">,</span> <span class="s1">'P'</span><span class="p">,</span> <span class="s1">'S'</span><span class="p">,</span> <span class="s1">'d'</span><span class="p">,</span> <span class="s1">'p'</span><span class="p">,</span> <span class="s1">'s'</span><span class="p">])</span><span class="o">.</span><span class="n">setResultsName</span><span class="p">(</span><span class="s2">"type"</span><span class="p">)</span> \
         <span class="o">+</span> <span class="n">pp</span><span class="o">.</span><span class="n">Optional</span><span class="p">(</span><span class="s1">'^'</span> <span class="o">+</span> <span class="n">pp</span><span class="o">.</span><span class="n">Word</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">nums</span><span class="p">)</span><span class="o">.</span><span class="n">setResultsName</span><span class="p">(</span><span class="s1">'within'</span><span class="p">))</span>
<span class="n">prox_b</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">Word</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">nums</span><span class="p">)</span><span class="o">.</span><span class="n">setResultsName</span><span class="p">(</span><span class="s1">'within'</span><span class="p">)</span> <span class="o">|</span> <span class="n">prox_a</span>

<span class="n">prox</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">Combine</span><span class="p">(</span>
    <span class="n">pp</span><span class="o">.</span><span class="n">Optional</span><span class="p">(</span><span class="s2">"PRE"</span><span class="p">)</span><span class="o">.</span><span class="n">setResultsName</span><span class="p">(</span><span class="s1">'order'</span><span class="p">)</span>
    <span class="o">+</span> <span class="s1">'/'</span>
    <span class="o">+</span> <span class="n">prox_b</span>
<span class="p">)</span><span class="o">.</span><span class="n">setResultsName</span><span class="p">(</span><span class="s1">'op'</span><span class="p">)</span>

<span class="n">prox_query</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">Group</span><span class="p">(</span><span class="s1">'['</span> <span class="o">+</span>
    <span class="n">pp</span><span class="o">.</span><span class="n">Word</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">alphanums</span><span class="p">)</span><span class="o">.</span><span class="n">setResultsName</span><span class="p">(</span><span class="s1">'q1'</span><span class="p">)</span>
    <span class="o">+</span> <span class="n">prox</span> <span class="o">+</span>
    <span class="n">pp</span><span class="o">.</span><span class="n">Word</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">alphanums</span><span class="p">)</span><span class="o">.</span><span class="n">setResultsName</span><span class="p">(</span><span class="s1">'q2'</span><span class="p">)</span>
<span class="o">+</span> <span class="s1">']'</span><span class="p">)</span><span class="o">.</span><span class="n">setResultsName</span><span class="p">(</span><span class="s1">'prox'</span><span class="p">)</span>

<span class="n">field_1</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">oneOf</span><span class="p">([</span><span class="s1">'CONTENT'</span><span class="p">,</span> <span class="s1">'content'</span><span class="p">])</span><span class="o">.</span><span class="n">setResultsName</span><span class="p">(</span><span class="s1">'field'</span><span class="p">)</span>
<span class="n">value_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">Word</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">alphanums</span><span class="p">)</span> <span class="o">|</span> <span class="n">pp</span><span class="o">.</span><span class="n">quotedString</span><span class="p">)</span><span class="o">.</span><span class="n">setResultsName</span><span class="p">(</span><span class="s1">'value'</span><span class="p">)</span> <span class="o">|</span> <span class="n">prox_query</span>
<span class="n">group_1</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">Group</span><span class="p">(</span><span class="n">field_1</span> <span class="o">+</span> <span class="s1">':'</span> <span class="o">+</span> <span class="n">value_1</span><span class="p">)</span>


<span class="n">field_2</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">oneOf</span><span class="p">([</span><span class="s1">'AUTHOR'</span><span class="p">,</span> <span class="s1">'YEAR'</span><span class="p">,</span> <span class="s1">'author'</span><span class="p">,</span> <span class="s1">'year'</span><span class="p">,</span> <span class="s1">'TITLE'</span><span class="p">,</span> <span class="s1">'DESCR'</span><span class="p">,</span> <span class="s1">'title'</span><span class="p">,</span> <span class="s1">'descr'</span><span class="p">])</span><span class="o">.</span><span class="n">setResultsName</span><span class="p">(</span><span class="s1">'field'</span><span class="p">)</span>
<span class="n">value_2</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="n">setResultsName</span><span class="p">(</span><span class="s1">'value'</span><span class="p">)</span>
<span class="n">group_2</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">Group</span><span class="p">(</span><span class="n">field_2</span> <span class="o">+</span> <span class="s1">':'</span> <span class="o">+</span> <span class="n">value_2</span><span class="p">)</span>
</code></pre></div><p data-pid="cHUrTWLu">我觉得写到这里完全不需要解释，因为每一句话基本都是和上面的文法一一对应的，除了setResultName这个函数。参考<a href="http://link.zhihu.com/?target=https%3A//pyparsing-docs.readthedocs.io/en/latest/pyparsing.html%3Fhighlight%3Dsetresult%23pyparsing.ParserElement.setResultsName" class=" wrap external" target="_blank" rel="nofollow noreferrer">官方文档</a>，setResultName可以给产生式解析出来的结果起名字。通过parseString方法我们可以直接将上面定义的文法当做解释器用：</p><div class="highlight"><pre><code class="language-python"><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">group_1</span><span class="o">.</span><span class="n">parseString</span><span class="p">(</span><span class="s1">'CONTENT : [hello PRE/D^1 b]'</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dump</span><span class="p">())</span>
<span class="o">-----------------------------------------------------------</span>
<span class="p">[</span><span class="s1">'CONTENT'</span><span class="p">,</span> <span class="s1">':'</span><span class="p">,</span> <span class="p">[</span><span class="s1">'['</span><span class="p">,</span> <span class="s1">'hello'</span><span class="p">,</span> <span class="p">[</span><span class="s1">'PRE/D^1'</span><span class="p">],</span> <span class="s1">'b'</span><span class="p">,</span> <span class="s1">']'</span><span class="p">]]</span>
<span class="o">-</span> <span class="n">field</span><span class="p">:</span> <span class="s1">'CONTENT'</span>
<span class="o">-</span> <span class="n">prox</span><span class="p">:</span> <span class="p">[</span><span class="s1">'['</span><span class="p">,</span> <span class="s1">'hello'</span><span class="p">,</span> <span class="p">[</span><span class="s1">'PRE/D^1'</span><span class="p">],</span> <span class="s1">'b'</span><span class="p">,</span> <span class="s1">']'</span><span class="p">]</span>
  <span class="o">-</span> <span class="n">op</span><span class="p">:</span> <span class="p">[</span><span class="s1">'PRE/D^1'</span><span class="p">]</span>
    <span class="o">-</span> <span class="n">order</span><span class="p">:</span> <span class="s1">'PRE'</span>
    <span class="o">-</span> <span class="nb">type</span><span class="p">:</span> <span class="s1">'D'</span>
    <span class="o">-</span> <span class="n">within</span><span class="p">:</span> <span class="s1">'1'</span>
  <span class="o">-</span> <span class="n">q1</span><span class="p">:</span> <span class="s1">'hello'</span>
  <span class="o">-</span> <span class="n">q2</span><span class="p">:</span> <span class="s1">'b'</span>
</code></pre></div><p data-pid="9I7J0h1b">通过result[0].asDict()可以直接获取解析出来的字典，刚刚setResultName定义出来的名字就是字典里嵌套的key，通过它们我们就可以获取到想要的那部分子表达式的值。以上步骤只是做了解析，但没有对结果进行操作，你当然可以自己写一个简单的算法去递归拆包计算表达式。因为表达式的优先级通过文法定义，已经体现在字典的嵌套关系里了。甚至可以直接使用set_parse_action函数在解析器里绑定一个操作。这部分我不会讲解的很详细，可以去官方文档里搜索这些函数，有很多示例。</p><p data-pid="hWTghC-G">目前为止我们还不能实现布尔表达式的功能，这里我使用了一个现成的布尔解析器<a href="http://link.zhihu.com/?target=https%3A//boolean-parser.readthedocs.io/en/latest/api.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">boolean_parser</a>。</p><div class="highlight"><pre><code class="language-python"><span></span><span class="kn">from</span> <span class="nn">boolean_parser.parsers</span> <span class="kn">import</span> <span class="n">Parser</span>
<span class="n">Parser</span><span class="o">.</span><span class="n">build_parser</span><span class="p">(</span><span class="n">clauses</span><span class="o">=</span><span class="p">[</span><span class="n">group_1</span><span class="p">,</span> <span class="n">group_2</span><span class="p">])</span>
<span class="n">query</span> <span class="o">=</span> <span class="s1">'CONTENT : [hello PRE/D^1 b] and TITLE : abc or AUTHOR : "Mark Twain"'</span>
<span class="nb">print</span><span class="p">(</span><span class="n">Parser</span><span class="p">()</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">query</span><span class="p">)</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">())</span>
<span class="o">-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span>
<span class="n">or_</span><span class="p">(</span><span class="n">and_</span><span class="p">(([</span><span class="s1">'CONTENT'</span><span class="p">,</span> <span class="s1">':'</span><span class="p">,</span> <span class="p">([</span><span class="s1">'['</span><span class="p">,</span> <span class="s1">'hello'</span><span class="p">,</span> <span class="p">([</span><span class="s1">'PRE/D^1'</span><span class="p">],</span> <span class="p">{</span><span class="s1">'order'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'PRE'</span><span class="p">],</span> <span class="s1">'type'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'D'</span><span class="p">],</span> <span class="s1">'within'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'1'</span><span class="p">]}),</span> <span class="s1">'b'</span><span class="p">,</span> <span class="s1">']'</span><span class="p">],</span> <span class="p">{</span><span class="s1">'q1'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'hello'</span><span class="p">],</span> <span class="s1">'op'</span><span class="p">:</span> <span class="p">[([</span><span class="s1">'PRE/D^1'</span><span class="p">],</span> <span class="p">{</span><span class="s1">'order'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'PRE'</span><span class="p">],</span> <span class="s1">'type'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'D'</span><span class="p">],</span> <span class="s1">'within'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'1'</span><span class="p">]})],</span> <span class="s1">'q2'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'b'</span><span class="p">]})],</span> <span class="p">{</span><span class="s1">'field'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'CONTENT'</span><span class="p">],</span> <span class="s1">'prox'</span><span class="p">:</span> <span class="p">[([</span><span class="s1">'['</span><span class="p">,</span> <span class="s1">'hello'</span><span class="p">,</span> <span class="p">([</span><span class="s1">'PRE/D^1'</span><span class="p">],</span> <span class="p">{</span><span class="s1">'order'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'PRE'</span><span class="p">],</span> <span class="s1">'type'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'D'</span><span class="p">],</span> <span class="s1">'within'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'1'</span><span class="p">]}),</span> <span class="s1">'b'</span><span class="p">,</span> <span class="s1">']'</span><span class="p">],</span> <span class="p">{</span><span class="s1">'q1'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'hello'</span><span class="p">],</span> <span class="s1">'op'</span><span class="p">:</span> <span class="p">[([</span><span class="s1">'PRE/D^1'</span><span class="p">],</span> <span class="p">{</span><span class="s1">'order'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'PRE'</span><span class="p">],</span> <span class="s1">'type'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'D'</span><span class="p">],</span> <span class="s1">'within'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'1'</span><span class="p">]})],</span> <span class="s1">'q2'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'b'</span><span class="p">]})]}),</span> <span class="p">([</span><span class="s1">'TITLE'</span><span class="p">,</span> <span class="s1">':'</span><span class="p">,</span> <span class="s1">'abc'</span><span class="p">],</span> <span class="p">{</span><span class="s1">'field'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'TITLE'</span><span class="p">],</span> <span class="s1">'value'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'abc'</span><span class="p">]})),</span> <span class="p">([</span><span class="s1">'AUTHOR'</span><span class="p">,</span> <span class="s1">':'</span><span class="p">,</span> <span class="s1">'"Mark Twain"'</span><span class="p">],</span> <span class="p">{</span><span class="s1">'field'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'AUTHOR'</span><span class="p">],</span> <span class="s1">'value'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'"Mark Twain"'</span><span class="p">]}))</span>
</code></pre></div><p data-pid="iRG4TtIT">这里解析的结果很冗长，我们可以通过绑定Action回调函数来修改每个子表达式解析时的返回值。我们以对应group1、用来处理书籍内容content字段条件的Action1为例。</p><div class="highlight"><pre><code class="language-python"><span></span><span class="k">def</span> <span class="nf">Action1</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">dd</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">asDict</span><span class="p">()</span>
    <span class="k">if</span> <span class="s1">'value'</span> <span class="ow">in</span> <span class="n">dd</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">dd</span><span class="p">[</span><span class="s1">'value'</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">'"'</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">"'"</span><span class="p">,</span> <span class="s2">""</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">command</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">'content'</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">value</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
    <span class="k">elif</span> <span class="s1">'prox'</span> <span class="ow">in</span> <span class="n">dd</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">dd</span><span class="p">[</span><span class="s1">'prox'</span><span class="p">]</span>
        <span class="n">q1</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="s1">'q1'</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">'"'</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">"'"</span><span class="p">,</span> <span class="s2">""</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">q2</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="s1">'q2'</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">'"'</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">"'"</span><span class="p">,</span> <span class="s2">""</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="s1">'op'</span><span class="p">]</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="s1">'order'</span> <span class="ow">in</span> <span class="n">op</span>
        <span class="n">where</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'type'</span><span class="p">,</span> <span class="s1">'D'</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'within'</span><span class="p">,</span> <span class="mf">1e9</span><span class="p">))</span>
        <span class="n">command</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">'content'</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">pre</span><span class="p">))</span>
    <span class="k">return</span> <span class="s1">'content'</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">command</span><span class="p">[</span><span class="s1">'content'</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
</code></pre></div><p data-pid="_Plw7iiK">data是对于group1处理的返回结果，dd是获取到的字典。首先判断字典是否包含value关键字，如果包含，则说明是类似<code>content: abc</code>的形式，否则冒号后面就是一个模糊搜索条件。我们使用replace去掉值的引号，使用lower函数将它们统一变为小写。command是一个全局字典，记录着我们将要执行的操作序列，有点儿类似编译里的四元式。这里command的content类型操作是五元组，分别记录文本1、文本2、相隔单词数、所在位置和是否可以调换顺序。然后我们将操作类别content返回，并且返回目前的指令在操作栈里的位置。类似的，我们编写Action2处理其他查询字段。接下来重新运行程序：</p><div class="highlight"><pre><code class="language-python"><span></span><span class="n">command</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">def</span> <span class="nf">Action1</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="o">...</span>
<span class="k">def</span> <span class="nf">Action2</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">dd</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">asDict</span><span class="p">()</span>
    <span class="n">field</span> <span class="o">=</span> <span class="n">dd</span><span class="p">[</span><span class="s1">'field'</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">dd</span><span class="p">[</span><span class="s1">'value'</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">'"'</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">"'"</span><span class="p">,</span> <span class="s2">""</span><span class="p">)</span>
    <span class="n">command</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">field</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">command</span><span class="p">[</span><span class="n">field</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
<span class="kn">from</span> <span class="nn">boolean_parser.parsers</span> <span class="kn">import</span> <span class="n">Parser</span>
<span class="n">Parser</span><span class="o">.</span><span class="n">build_parser</span><span class="p">(</span><span class="n">clauses</span><span class="o">=</span><span class="p">[</span><span class="n">group_1</span><span class="p">,</span> <span class="n">group_2</span><span class="p">],</span> <span class="n">actions</span><span class="o">=</span><span class="p">[</span><span class="n">Action1</span><span class="p">,</span> <span class="n">Action2</span><span class="p">])</span>
<span class="n">query</span> <span class="o">=</span> <span class="s1">'CONTENT : [hello PRE/D^1 b] and TITLE : abc or AUTHOR : "Mark Twain"'</span>
<span class="nb">print</span><span class="p">(</span><span class="n">Parser</span><span class="p">()</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">query</span><span class="p">)</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">command</span><span class="p">)</span>
<span class="o">---------------------------------------------------------------------------------------</span>
<span class="n">or_</span><span class="p">(</span><span class="n">and_</span><span class="p">((</span><span class="s1">'content'</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s1">'title'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="p">(</span><span class="s1">'author'</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="p">{</span><span class="s1">'content'</span><span class="p">:</span> <span class="p">[(</span><span class="s1">'hello'</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">'D'</span><span class="p">,</span> <span class="kc">True</span><span class="p">)],</span> <span class="s1">'title'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'abc'</span><span class="p">],</span> <span class="s1">'author'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'Mark Twain'</span><span class="p">]}</span>
</code></pre></div><p data-pid="7Kah8Y2U">这样我们就得到了要操作的指令集command，也发现布尔表达式的结果变得很清晰。我们循环遍历command的中间指令，通过查询索引找到结果，将结果暂存在字典response_tmp里，然后我们再想办法根据布尔逻辑语义去组合这些中间结果（我这里没有考虑效率优化，比如短路原则）。</p><p data-pid="ml-8oCIB">我在官方文档上没有找到布尔表达式解释器的结果怎么变成操作，索性直接将结果看做是函数的嵌套调用，然后使用eval去执行它。此时我们只需要编写三个函数即可：or_、and_、not_。这里我只给出and_函数的示例，大家可以体会一下：</p><div class="highlight"><pre><code class="language-python"><span></span><span class="k">def</span> <span class="nf">and_</span><span class="p">(</span><span class="o">*</span><span class="n">params</span><span class="p">):</span>
    <span class="n">sets</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">response_tmp</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">params</span><span class="p">]</span>
    <span class="n">docs</span> <span class="o">=</span> <span class="n">sets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="n">sets</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="n">field_ret</span><span class="p">,</span> <span class="n">i_ret</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">docs</span><span class="p">:</span>
            <span class="n">temp</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">response_tmp</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">doc</span><span class="p">])</span>
    <span class="n">response_tmp</span><span class="p">[</span><span class="n">field_ret</span><span class="p">][</span><span class="n">i_ret</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>
    <span class="k">return</span> <span class="n">field_ret</span><span class="p">,</span> <span class="n">i_ret</span>
</code></pre></div><p data-pid="t9qz81x9">通过对变长参数params解析，得到字段和结果栈位置索引对，取出所有的查询结果，通过set的intersection操作求出交集然后再将交集的结果保存回response_tmp中params第一个传入参数的位置上，将该字段名和结果栈位置索引返回。用同样的方法编写or_与not_函数，然后我们对布尔解释器的结果进行eval就实现了布尔表达式的逻辑。</p><div class="highlight"><pre><code class="language-python"><span></span><span class="nb">eval</span><span class="p">(</span><span class="n">Parser</span><span class="p">()</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">query</span><span class="p">)</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">())</span>
<span class="c1"># 在上述情景下等价于调用or_(and_(('content', 0), ('title', 0)), ('author', 0))</span>
</code></pre></div><hr><p data-pid="F51ixR8L">当然本文主要关注较为复杂的语法，而对于算数表达式这种简单语法来说，我们通常会使用正则表达式（实际上是个状态机的套件）来识别数字，然后借助栈来获得逆波兰式并进行计算。我们也可以使用别的方法获得逆波兰式，我在本科的时候写过：<a href="http://link.zhihu.com/?target=https%3A//blog.csdn.net/shanchenglang/article/details/103494264%3Fspm%3D1001.2014.3001.5501" class=" wrap external" target="_blank" rel="nofollow noreferrer">递归法求解算术表达式</a>。</p><p></p>