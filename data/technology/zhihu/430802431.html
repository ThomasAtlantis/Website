<h2>1 写在前面</h2><h3>1.1 冒险小虎队</h3><p data-pid="afzTwTMS">多年以后，博士生清川偶然回想起在新华书店，品读「冒险小虎队」的那个遥远的下午，那是他第一次见识到莫列波纹。他喜欢席地而坐，让金色的阳光绕过窗栏流入他的头发，那时的日子像影子一样悠长。他不会英语也不懂物理，不知道什么是Moiré pattern，只知道拥有了小虎队的解密卡就能成为孩子王。那是一种风靡一时的神秘科技：解密区看起来灰蒙蒙一片，用一张半透明的卡片贴上去来回移动，秘密文字便悄然显现。</p><p data-pid="eua_7laI">事到如今，恍然醒悟：这解密卡里大有文章！上学期听学院陈奕超老师的讲座，得知他在2019年MobiCom上发表了一篇利用莫列波纹做二维码隐私保护的文章<sup data-text="mQRCode: Secure QR Code Using Nonlinearity of Spatial Frequency in Light" data-url="https://dl.acm.org/doi/pdf/10.1145/3300061.3345428" data-draft-node="inline" data-draft-type="reference" data-numero="1">[1]</sup>。之前总有新闻报导提醒我们排队的时候不要提前把付款码亮出来，容易被别有用心之人盗刷，而这篇文章则通过显示技术一劳永逸：将二维码用特殊的条纹加密，摄像头由于CFA<sup data-text="Color Filter Array" data-url="http://www.wangdali.net/cfa/" data-draft-node="inline" data-draft-type="reference" data-numero="2">[2]</sup>（Color Filter Array，色彩滤镜矩阵）产生莫列波纹，只有在恰当的角度和距离才能正确解密。类比一下，CFA就是小虎队里的解密卡，而付款码就是要解密的文字呀。</p><figure data-size="normal"><noscript><img src="https://picx.zhimg.com/v2-38ac359185738e875b5466ed82fcbe12_720w.jpg?source=d16d100b" data-size="normal" data-rawwidth="1250" data-rawheight="384" class="origin_image zh-lightbox-thumb" width="1250" data-original="https://picx.zhimg.com/v2-38ac359185738e875b5466ed82fcbe12_720w.jpg?source=d16d100b"></noscript><img src="data:image/svg+xml;utf8,&lt;svg%20xmlns='http://www.w3.org/2000/svg'%20width='1250'%20height='384'&gt;&lt;/svg&gt;" data-size="normal" data-rawwidth="1250" data-rawheight="384" class="origin_image zh-lightbox-thumb lazy" width="1250" data-original="https://picx.zhimg.com/v2-38ac359185738e875b5466ed82fcbe12_720w.jpg?source=d16d100b" data-actualsrc="https://picx.zhimg.com/v2-38ac359185738e875b5466ed82fcbe12_720w.jpg?source=d16d100b"><figcaption>图源：mQRCode: Secure QR Code Using Nonlinearity ofSpatial Frequency in Light</figcaption></figure><h3>1.2 光栅动画卡</h3><p data-pid="RL6HRZfM">在那个智能手机尚未普及的年代，90后朴实无华但并不枯燥，很多玩具看似廉价实则十分黑科技。其中让我印象最深的，一个是利用齿轮画内旋轮线的万花尺，现在你可以在网上欣赏艺术家的作品：<a href="http://link.zhihu.com/?target=https%3A//www.dirtalleydesign.com/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Generative Art by Michelle Chandra - Drawn with an Axidraw pen plotter</a>；另一个就是光栅动画卡，一个印在纸上的交互式GIF图。对于后者，也就是本文的主角，我愿称之为时序图案的空分复用变换，其原理竟然与小虎队的解密卡不谋而合：通过一个印有平行条纹的透明卡片在特殊的图案上滑动，就可以看到图案动了起来。</p><p data-pid="61YegQbQ">辗转多地、白驹过隙，我已回忆不出童年时那几张图样的具体内容，也想不起这份廉价而高端的玩具收藏在何处，但如今我却掌握了制作这种玩具的能力。了解了其中显而易见的原理，使用程序将任意GIF图转换成这种形式也绝非难事。</p><figure data-size="normal"><noscript><img src="https://picx.zhimg.com/v2-fb4ce6efb5fa62c0767d766484150cc9_720w.gif?source=d16d100b" data-size="normal" data-rawwidth="860" data-rawheight="200" data-thumbnail="https://picx.zhimg.com/v2-fb4ce6efb5fa62c0767d766484150cc9_720w.jpg?source=d16d100b" class="origin_image zh-lightbox-thumb" width="860" data-original="https://picx.zhimg.com/v2-fb4ce6efb5fa62c0767d766484150cc9_720w.jpg?source=d16d100b"></noscript><img src="data:image/svg+xml;utf8,&lt;svg%20xmlns='http://www.w3.org/2000/svg'%20width='860'%20height='200'&gt;&lt;/svg&gt;" data-size="normal" data-rawwidth="860" data-rawheight="200" data-thumbnail="https://picx.zhimg.com/v2-fb4ce6efb5fa62c0767d766484150cc9_720w.jpg?source=d16d100b" class="origin_image zh-lightbox-thumb lazy" width="860" data-original="https://picx.zhimg.com/v2-fb4ce6efb5fa62c0767d766484150cc9_720w.jpg?source=d16d100b" data-actualsrc="https://picx.zhimg.com/v2-fb4ce6efb5fa62c0767d766484150cc9_720w.gif?source=d16d100b"><figcaption>图源百度图片词条「光栅动画 gif」，侵删</figcaption></figure><p data-pid="9_Tn1ubC">本文将会详细介绍莫列波纹和光栅动画的原理，并以HTML5和Python编程实现为例，讲解GIF图如何自动转化为这种可以打印的视觉错觉图案。目前网上资料大多是博人眼球的营销软文，或PS修图技巧，未有对编程实现的详细讲解，希望本文能够作为补充，教会大家如何自娱自乐。<b>如果只对编程实现感兴趣，可以跳过前面的科普，直接进入3.2小节。</b></p><h2>2 莫列波纹</h2><h3>2.1 概念解析</h3><p data-pid="6PgMSqIo">Moiré patterns (/mwɑːˈreɪ/，其中r是小舌颤音，所以被译作莫列/莫尔/摩尔都合理 [<a href="http://link.zhihu.com/?target=http%3A//api.frdic.com/api/v2/speech/speakweb%3Flangid%3Dfr%26txt%3DQYNbW9pcsOp" class=" wrap external" target="_blank" rel="nofollow noreferrer">读音参考</a>]）<b>是一种常见光学现象：当某个具有透明缝隙的重复条纹图案覆盖在另一个上面，就会观测到更大尺度的干涉图样</b>。类比时序信号，这种波纹是空间上分布的信号，在某个方向上每隔一定距离便周期性重复排列，具有「空间频率」。我们知道行波要产生稳定干涉，要求频率相近相位不同，那么与之类比，要产生这种莫列波纹，两层图案往往尺度相差不能过大，但在位置、角度或透视上有所不同。论文[1]中给出了一个直观的解释：</p><blockquote data-pid="ACJvwXyW">Human eyes are more sensitive to low frequency signals。</blockquote><p data-pid="XP3B1qGd">高频的图案粒度更细，在远处看，视线夹角一旦超过了<a href="http://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%25E7%2591%259E%25E5%2588%25A9%25E5%2588%25A4%25E6%258D%25AE/2760374%3Ffr%3Daladdin" class=" wrap external" target="_blank" rel="nofollow noreferrer">最小分辨角</a>即不可区分，看起来就是一片灰色，这时低频的图案就显得更加清晰。</p><h3>2.2 日常现象</h3><p data-pid="P4CC6FUx">莫列波纹现象在生活中十分常见：</p><p data-pid="H1xPHo6N">1）比如使用手机拍摄电脑屏幕或具有细密花纹的丝绸时会产生不规则条纹，原因就是摄像头本身的色彩滤镜层是空间重复排列的且粒度有限，与被拍摄的花纹产生了叠加和干涉。</p><p data-pid="3aU_hUT4">2）另外，讲一个古老而有趣的技术：Halftone半色调。它使用不同大小和密度的圆点来模拟颜色的深浅，比如白色背景下大量稀疏排布的黑色圆点，在远处看可能呈现出的颜色更接近灰色。利用这种方法，我们可以实现仿色渐变压缩存储图片所需的颜色数，这种印刷技术以前很常见，现在多见于有轨电车的波普艺术皮肤和钢笔画中。在计算机扫描这种印刷品时也会出现莫列波纹。</p><p data-pid="QmggWoW2">3）在光线追踪算法遇到棋盘样的图案时，如果对远景用传统方式渲染，就会出现干扰的花纹，称作稀疏采样导致的aliasing现象，这时需要使用MipMap技术自适应地选择不同的贴图分辨率。</p><figure data-size="normal"><noscript><img src="https://pica.zhimg.com/v2-77494d62d8d133167600a76bce336fd1_720w.jpg?source=d16d100b" data-size="normal" data-rawwidth="1920" data-rawheight="540" class="origin_image zh-lightbox-thumb" width="1920" data-original="https://picx.zhimg.com/v2-77494d62d8d133167600a76bce336fd1_720w.jpg?source=d16d100b"></noscript><img src="data:image/svg+xml;utf8,&lt;svg%20xmlns='http://www.w3.org/2000/svg'%20width='1920'%20height='540'&gt;&lt;/svg&gt;" data-size="normal" data-rawwidth="1920" data-rawheight="540" class="origin_image zh-lightbox-thumb lazy" width="1920" data-original="https://picx.zhimg.com/v2-77494d62d8d133167600a76bce336fd1_720w.jpg?source=d16d100b" data-actualsrc="https://pica.zhimg.com/v2-77494d62d8d133167600a76bce336fd1_720w.jpg?source=d16d100b"><figcaption>图源：维基百科MipMapping词条</figcaption></figure><p data-pid="6iFfdfmM">4）据说两个离得比较近的钢丝网眼栅栏在远处看都会产生干涉。由于近大远小的透视关系，远处的网眼会比近处的小一些，两层的图案在局部不能完全对齐，但在整体上又会周期性重合，所以就会呈现更大的网眼图案，这被称作Shape moiré的放大现象。</p><h3>2.3 词源历史</h3><p data-pid="zdGS4UdJ">实际上莫列这个单词本身就来源于日常生活：Moiré是法语词，原意指一种具有特殊纹路的织物，传统工艺使用丝绸制作，但现在也会使用棉和合成纤维。这种织物是在浸水的状态下将两层布料压在一起制成的，所以也会被称作「watered textile」，由于两层布料中的线在空间上分布不完全相同，压在一起就会产生一些特殊的花纹，而这种花纹在干燥后会保持下来。这个制布的过程听起来就和上面描述的光学现象产生原理十分相似。这种特殊花纹难以形容，参考下图：</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-3c54c4ca041cd4c706a47bcfa6f68a3e_720w.jpg?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="800" data-rawheight="349" class="origin_image zh-lightbox-thumb" width="800" data-original="https://pic1.zhimg.com/v2-3c54c4ca041cd4c706a47bcfa6f68a3e_720w.jpg?source=d16d100b"></noscript><img src="data:image/svg+xml;utf8,&lt;svg%20xmlns='http://www.w3.org/2000/svg'%20width='800'%20height='349'&gt;&lt;/svg&gt;" data-caption="" data-size="normal" data-rawwidth="800" data-rawheight="349" class="origin_image zh-lightbox-thumb lazy" width="800" data-original="https://pic1.zhimg.com/v2-3c54c4ca041cd4c706a47bcfa6f68a3e_720w.jpg?source=d16d100b" data-actualsrc="https://pic1.zhimg.com/v2-3c54c4ca041cd4c706a47bcfa6f68a3e_720w.jpg?source=d16d100b"></figure><p data-pid="kZHoAm5g">Moiré这个单词再往前推演，最早来源于阿拉伯语词汇mukhayyar，是一种使用土耳其的安哥拉山羊毛制作的精细编织布。14至15世纪传到欧洲各国，逐渐形成英语词mohair。而后17世纪时，法语借用这个单词形成名词形式moire表示水丝绸，而后出现动词moirer表示压制水丝绸的过程。18世纪时最终形成形容词moiré，用以表示这种特殊的花纹。在百度百科以及一些知乎文章（例如5k赞同的回答<a href="https://www.zhihu.com/question/21650222/answer/483982960" class="internal" target="_blank">《冒险小虎队》的解密卡的原理是什么？</a>）中<b>杜撰说莫列波纹是18世纪由法国研究员莫列最早发现，毫无根据</b>。另外，有较为权威的外文书籍或文献<sup data-text="Optical Measurement Mechanics - Geometric moiré and moiré interferometry" data-url="https://www.degruyter.com/document/doi/10.1515/9783110573053/html" data-draft-node="inline" data-draft-type="reference" data-numero="3">[3]</sup><sup data-text="Moirés" data-url="https://www.sciencedirect.com/science/article/pii/B978008033986350029X" data-draft-node="inline" data-draft-type="reference" data-numero="4">[4]</sup><sup data-text="Moiré Metamaterials and Metasurfaces" data-url="https://onlinelibrary.wiley.com/doi/10.1002/adom.201701057" data-draft-node="inline" data-draft-type="reference" data-numero="5">[5]</sup><sup data-text="Variational approach to moiré pattern synthesis" data-url="https://www.osapublishing.org/abstract.cfm?uri=JOSAA-18-6-1371" data-draft-node="inline" data-draft-type="reference" data-numero="6">[6]</sup><sup data-text="The Theory of the Moiré Phenomenon - Introduction" data-url="https://link.springer.com/book/10.1007/978-1-84882-181-1" data-draft-node="inline" data-draft-type="reference" data-numero="7">[7]</sup>认为以上提到的丝绸压制方法源于中国、后来由法国引进，其中一些文章甚至认为中国最早发现并制造莫列波纹，我认为也未必可信，比如[4]中提到：</p><figure data-size="normal"><noscript><img src="https://picx.zhimg.com/v2-7b478dedfe417606c3315a8fc8af3287_720w.png?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="865" data-rawheight="89" class="origin_image zh-lightbox-thumb" width="865" data-original="https://picx.zhimg.com/v2-7b478dedfe417606c3315a8fc8af3287_720w.jpg?source=d16d100b"></noscript><img src="data:image/svg+xml;utf8,&lt;svg%20xmlns='http://www.w3.org/2000/svg'%20width='865'%20height='89'&gt;&lt;/svg&gt;" data-caption="" data-size="normal" data-rawwidth="865" data-rawheight="89" class="origin_image zh-lightbox-thumb lazy" width="865" data-original="https://picx.zhimg.com/v2-7b478dedfe417606c3315a8fc8af3287_720w.jpg?source=d16d100b" data-actualsrc="https://picx.zhimg.com/v2-7b478dedfe417606c3315a8fc8af3287_720w.png?source=d16d100b"></figure><p data-pid="ooxrnFak">但我还是倾向于相信这种丝绸制法是16到17世纪法国人自己发明的，参考：<a href="http://link.zhihu.com/?target=https%3A//www.veranda.com/home-decorators/a27105022/the-history-of-silk/" class=" wrap external" target="_blank" rel="nofollow noreferrer">How Silk Became the Most Sought-After Textile in History</a>。Moiré一词确实也用来指代中国丝绸上的云纹，但那种云纹往往是直接织上去的。不能因为云纹、丝绸都与中国相关，就认定它是中国发明的，这段历史的辨析还是留给历史系的同学吧。我们至少知道，莫列波纹的发现很可能晚于18世纪，而现代研究起始于19世纪下半叶。</p><h3>2.4 数学分析</h3><p data-pid="fpBxsD5s">下面我们从数学上简单地推导一下平行条纹的光栅重叠时的干涉现象，如果对数学不感兴趣可以跳过这一节。本节主要参考了论文[1]的Spatial Frequency一节。</p><p data-pid="CWJtFlYy">使用数值范围在 <img src="https://www.zhihu.com/equation?tex=%5B0%2C1%5D" alt="[0,1]" eeimg="1"> 的二维矩阵 <img src="https://www.zhihu.com/equation?tex=m%28x%2Cy%29" alt="m(x,y)" eeimg="1"> 表示图案，其中0表示黑色，1表示白色。其中 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"> 、 <img src="https://www.zhihu.com/equation?tex=y" alt="y" eeimg="1"> 表示像素位置的纵、横坐标，这里坐标系不太一样， <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"> 正方向向下， <img src="https://www.zhihu.com/equation?tex=y" alt="y" eeimg="1"> 的正方向向右。文章将图案的表示 <img src="https://www.zhihu.com/equation?tex=m%28x%2Cy%29" alt="m(x,y)" eeimg="1"> 进一步分解成为相位 <img src="https://www.zhihu.com/equation?tex=%5Cphi%28x%2Cy%29" alt="\phi(x,y)" eeimg="1"> 和周期 <img src="https://www.zhihu.com/equation?tex=p%28u%29" alt="p(u)" eeimg="1"> 的复合函数：</p><p data-pid="xacnaIcy"><img src="https://www.zhihu.com/equation?tex=m%28x%2Cy%29+%3D+p%28%5Cphi%28x%2Cy%29%29%5C%5C" alt="m(x,y) = p(\phi(x,y))\\" eeimg="1"> </p><p data-pid="nkEtOZQZ">其中相位指的是图像的旋转角度，比如竖直重复的条纹「||||」不同位置的像素值只与纵坐标 <img src="https://www.zhihu.com/equation?tex=x" alt="x" eeimg="1"> 有关，则相位函数可以表示为： <img src="https://www.zhihu.com/equation?tex=%5Cphi%28x%2Cy%29%3Dx" alt="\phi(x,y)=x" eeimg="1"> ，如果是斜向右下重复的条纹「\\\\」则可以表示为： <img src="https://www.zhihu.com/equation?tex=%5Cphi%28x%2Cy%29%3Dk_1x%2Bk_2y" alt="\phi(x,y)=k_1x+k_2y" eeimg="1"> ，其中 <img src="https://www.zhihu.com/equation?tex=k" alt="k" eeimg="1"> 是正数。下面三幅图给出了周期函数、相位函数和最终的图案之间的关系的例子：</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-a88d193051946c71fa0a9e26d0afb4e5_720w.jpg?source=d16d100b" data-size="normal" data-rawwidth="746" data-rawheight="277" class="origin_image zh-lightbox-thumb" width="746" data-original="https://picx.zhimg.com/v2-a88d193051946c71fa0a9e26d0afb4e5_720w.jpg?source=d16d100b"></noscript><img src="data:image/svg+xml;utf8,&lt;svg%20xmlns='http://www.w3.org/2000/svg'%20width='746'%20height='277'&gt;&lt;/svg&gt;" data-size="normal" data-rawwidth="746" data-rawheight="277" class="origin_image zh-lightbox-thumb lazy" width="746" data-original="https://picx.zhimg.com/v2-a88d193051946c71fa0a9e26d0afb4e5_720w.jpg?source=d16d100b" data-actualsrc="https://pic1.zhimg.com/v2-a88d193051946c71fa0a9e26d0afb4e5_720w.jpg?source=d16d100b"><figcaption>图源：mQRCode: Secure QR Code Using Nonlinearity ofSpatial Frequency in Light</figcaption></figure><p data-pid="6RqBJsZx">定义 <img src="https://www.zhihu.com/equation?tex=m" alt="m" eeimg="1"> 为两层图案 <img src="https://www.zhihu.com/equation?tex=m_1" alt="m_1" eeimg="1"> 和 <img src="https://www.zhihu.com/equation?tex=m_2" alt="m_2" eeimg="1"> 的叠加结果，则有：</p><p data-pid="PkTijlpX"><img src="https://www.zhihu.com/equation?tex=m%28x%2Cy%29%3Dm_1%28x%2Cy%29%5Ctimes+m_2%28x%2Cy%29%5C%5C" alt="m(x,y)=m_1(x,y)\times m_2(x,y)\\" eeimg="1"> </p><p data-pid="HCfgclHh">这里的乘法是逐像素相乘。为什么是乘法而不是加法呢？好像印象中波的叠加都是直接相加，这里有何特殊之处？其实特殊之处就在于，这里两层图案是透光叠加。在波源处，两个时序信号叠加确实是直接相加，但在透光叠加时，图案的像素值相当于光线能够通过的概率，那么连续通过两层图案的概率当然是二者逐元素相乘。类比时序信号，这里可以看做第二层图案对第一层图案进行了调制。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-ca8cd0e377688382a8617982c939d38d_720w.jpg?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="1920" data-rawheight="722" class="origin_image zh-lightbox-thumb" width="1920" data-original="https://picx.zhimg.com/v2-ca8cd0e377688382a8617982c939d38d_720w.jpg?source=d16d100b"></noscript><img src="data:image/svg+xml;utf8,&lt;svg%20xmlns='http://www.w3.org/2000/svg'%20width='1920'%20height='722'&gt;&lt;/svg&gt;" data-caption="" data-size="normal" data-rawwidth="1920" data-rawheight="722" class="origin_image zh-lightbox-thumb lazy" width="1920" data-original="https://picx.zhimg.com/v2-ca8cd0e377688382a8617982c939d38d_720w.jpg?source=d16d100b" data-actualsrc="https://pic1.zhimg.com/v2-ca8cd0e377688382a8617982c939d38d_720w.jpg?source=d16d100b"></figure><p data-pid="46EWHxnk">上图左上角是待调制的信号，右上角是高频载波，二者直接相加得到左下角，可以理解为在原信号的基础上引入了微小的高频抖动，信号大致波形保持不变。而右下角是二者相乘的结果，相当于调幅，把载波看做下层图案，原信号看做上层图案，则明显各个时刻能通过的光线能量（体现在振幅上）的大小主要由原信号决定。</p><p data-pid="bdV-cWie">如果我们用余弦函数分别表示两个图案，则它们的叠加有如下结果：</p><p data-pid="A6MFuYRF"><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%2A%7D+m%26%3Dm_1%5Ctimes+m_2%3D%28a_1%2Bb_1%5Ccos%282%5Cpi+f_1t%29%29%5Ctimes%28a_2%2Bb_2%5Ccos%282%5Cpi+f_2t%29%29%5C%5C+%26%3Da_1a_2%2Ba_1b_2%5Ccos%282%5Cpi+f_2t%29%2Ba_2b_1%5Ccos%282%5Cpi+f_1t%29%2Bb_1b_2%5Ccos%282%5Cpi%28f_1%2Bf_2%29t%29%5C%5C+%26%2Bb_1b_2%5Ccos%282%5Cpi%28f_1-f_2%29t%29+%5Cend%7Balign%2A%7D%5C%5C" alt="\begin{align*} m&amp;=m_1\times m_2=(a_1+b_1\cos(2\pi f_1t))\times(a_2+b_2\cos(2\pi f_2t))\\ &amp;=a_1a_2+a_1b_2\cos(2\pi f_2t)+a_2b_1\cos(2\pi f_1t)+b_1b_2\cos(2\pi(f_1+f_2)t)\\ &amp;+b_1b_2\cos(2\pi(f_1-f_2)t) \end{align*}\\" eeimg="1"> </p><p data-pid="4xSD138f">其中空间频率 <img src="https://www.zhihu.com/equation?tex=f" alt="f" eeimg="1"> 是二维矢量，表示图案沿着哪个方向重复。可以看到，在两个图案叠加之后新增了频率 <img src="https://www.zhihu.com/equation?tex=f_1%2Bf_2" alt="f_1+f_2" eeimg="1"> 与 <img src="https://www.zhihu.com/equation?tex=f_1-f_2" alt="f_1-f_2" eeimg="1"> ，由于我们肉眼对低频信号更敏感，后者就体现为较为清晰的莫列波纹。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-bff46fe1d416996b54d425e9f2b7ee12_720w.jpg?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="1500" data-rawheight="557" class="origin_image zh-lightbox-thumb" width="1500" data-original="https://picx.zhimg.com/v2-bff46fe1d416996b54d425e9f2b7ee12_720w.jpg?source=d16d100b"></noscript><img src="data:image/svg+xml;utf8,&lt;svg%20xmlns='http://www.w3.org/2000/svg'%20width='1500'%20height='557'&gt;&lt;/svg&gt;" data-caption="" data-size="normal" data-rawwidth="1500" data-rawheight="557" class="origin_image zh-lightbox-thumb lazy" width="1500" data-original="https://picx.zhimg.com/v2-bff46fe1d416996b54d425e9f2b7ee12_720w.jpg?source=d16d100b" data-actualsrc="https://pic1.zhimg.com/v2-bff46fe1d416996b54d425e9f2b7ee12_720w.jpg?source=d16d100b"></figure><p data-pid="jcndGdJa">当两层图案的函数表示为一般周期函数时，我们可以知道它们在频域的关系：</p><p data-pid="qusZIiSV"><img src="https://www.zhihu.com/equation?tex=M%28x%2Cy%29%3DM_1%28x%2Cy%29%5Cotimes+M_2%28x%2Cy%29%5C%5C" alt="M(x,y)=M_1(x,y)\otimes M_2(x,y)\\" eeimg="1"> </p><p data-pid="4qAuwlE3">这里 <img src="https://www.zhihu.com/equation?tex=M" alt="M" eeimg="1"> 表示 <img src="https://www.zhihu.com/equation?tex=m" alt="m" eeimg="1"> 经过傅里叶变换的结果， <img src="https://www.zhihu.com/equation?tex=%5Cotimes" alt="\otimes" eeimg="1"> 表示卷积。时域信号的乘积对应频域的卷积，这是线性时不变系统的结论，证明也并不复杂，这里不再展开，大家如果感兴趣可以私信我。根据[5]一书中的莫列定理，以上定义的周期函数和相位函数是独立的，最终我们可以得到低频的莫列条纹的公式：</p><p data-pid="TO7aHE9x"><img src="https://www.zhihu.com/equation?tex=p_%7Bnl%7D%28u%29%3DIFT%28FT%28p_1%28u%29%29%5Ccdot+FT%28p_2%28-u%29%29%29%2C+%5C+%5Cphi_%7Bnl%7D%28x%2Cy%29%3D%5Cphi_1%28x%2Cy%29-%5Cphi_2%28x%2Cy%29%5C%5C" alt="p_{nl}(u)=IFT(FT(p_1(u))\cdot FT(p_2(-u))), \ \phi_{nl}(x,y)=\phi_1(x,y)-\phi_2(x,y)\\" eeimg="1"> </p><h3>2.5 应用场景</h3><p data-pid="1BL1wawm">莫列波纹的现象在多数情况下是想要消除的副作用，但可控的莫列波纹也会用于标识、测量、防伪和艺术创作。</p><p data-pid="q9F4IITf">1）上文提到的利用莫列波纹对文字或图案（二维码）进行加密和解密，来保护隐私安全。</p><p data-pid="lfsT7BeH">2）瑞典的Inogon公司利用莫列波纹现象在（N50°51.36'，W1°19.746'）海岸建立了一个特殊的灯塔，用来为航船指示安全的入港路线，在接近危险水域时，船员看到灯塔的条纹形状就会变为垂直条纹，远离危险时，灯塔就会重新变为箭头的形状，指示安全的方向，如下图所示：</p><figure data-size="normal"><noscript><img src="https://picx.zhimg.com/v2-3bcc0cb77932f2f080d9b20321d6353e_720w.jpg?source=d16d100b" data-size="normal" data-rawwidth="1047" data-rawheight="588" class="origin_image zh-lightbox-thumb" width="1047" data-original="https://picx.zhimg.com/v2-3bcc0cb77932f2f080d9b20321d6353e_720w.jpg?source=d16d100b"></noscript><img src="data:image/svg+xml;utf8,&lt;svg%20xmlns='http://www.w3.org/2000/svg'%20width='1047'%20height='588'&gt;&lt;/svg&gt;" data-size="normal" data-rawwidth="1047" data-rawheight="588" class="origin_image zh-lightbox-thumb lazy" width="1047" data-original="https://picx.zhimg.com/v2-3bcc0cb77932f2f080d9b20321d6353e_720w.jpg?source=d16d100b" data-actualsrc="https://picx.zhimg.com/v2-3bcc0cb77932f2f080d9b20321d6353e_720w.jpg?source=d16d100b"><figcaption>图源：http://www.listoflights.org/leuchtfeuer/detail?id=487</figcaption></figure><p data-pid="KLGd8A_L">3）最常见的应用还是用于制造业检测材料的微观应变：材料在受应力时表面的网格变形，从而能观测到不同的莫列波纹，并由此推算出应力的大小和作用的位置。类似地，大家可以尝试一下，用手机拍摄电脑屏幕，然后根据拍摄出的莫列波纹推算一下手机的视角。</p><p data-pid="N9DFKUla">4）很多钞票上会印刷细密的圆点或波浪条纹来防止通过复印的方式伪造假币，扫描仪是无法精确扫描出原图的，会在表面形成严重的干涉条纹。</p><p data-pid="MWr8fMAT">5）那么重点来了，很多艺术家就喜欢利用人眼的视错觉来创造作品，莫列波纹其实很广泛地用于制作光栅动画，下面我将详细介绍其中的原理。</p><h2>3 光栅动画</h2><p data-pid="iLJFRoJy">光栅/栅格动画：是一种通过在底图上移动具有重复花纹的透明光栅，使肉眼可观察到动态效果的动画技术，最早出现于19世纪90年代。英文与之对应的关键词有：Barrier-grid animation、picket-fence animation、Moiré animation、Kinegrams等。由于知乎新版编辑器不能上传1MB以上的GIF图，大家可以在网站<a href="http://link.zhihu.com/?target=https%3A//www.giannisarcone.com/Kinegrams.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">Gianni Sarcone's Kinetic Art</a>在线欣赏，或者也可以在<a href="http://link.zhihu.com/?target=https%3A//www.giannisarcone.com/kinegram_rotor.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">这里</a>直接进行交互体验。</p><p data-pid="ueVZppWN">下面放几张简单的图，大家感受一下：</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-bd63ea88994dabc3e5f0818aae2ea2ed_720w.gif?source=d16d100b" data-size="normal" data-rawwidth="370" data-rawheight="219" data-thumbnail="https://picx.zhimg.com/v2-bd63ea88994dabc3e5f0818aae2ea2ed_720w.jpg?source=d16d100b" class="content_image" width="370"></noscript><img src="data:image/svg+xml;utf8,&lt;svg%20xmlns='http://www.w3.org/2000/svg'%20width='370'%20height='219'&gt;&lt;/svg&gt;" data-size="normal" data-rawwidth="370" data-rawheight="219" data-thumbnail="https://picx.zhimg.com/v2-bd63ea88994dabc3e5f0818aae2ea2ed_720w.jpg?source=d16d100b" class="content_image lazy" width="370" data-actualsrc="https://pic1.zhimg.com/v2-bd63ea88994dabc3e5f0818aae2ea2ed_720w.gif?source=d16d100b"><figcaption>图源：https://www.pinterest.co.uk/pin/71776187791443439/</figcaption></figure><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-59400b197e0f03d9c67db03a18df0114_720w.gif?source=d16d100b" data-size="normal" data-rawwidth="370" data-rawheight="250" data-thumbnail="https://pic1.zhimg.com/v2-59400b197e0f03d9c67db03a18df0114_720w.jpg?source=d16d100b" class="content_image" width="370"></noscript><img src="data:image/svg+xml;utf8,&lt;svg%20xmlns='http://www.w3.org/2000/svg'%20width='370'%20height='250'&gt;&lt;/svg&gt;" data-size="normal" data-rawwidth="370" data-rawheight="250" data-thumbnail="https://pic1.zhimg.com/v2-59400b197e0f03d9c67db03a18df0114_720w.jpg?source=d16d100b" class="content_image lazy" width="370" data-actualsrc="https://pic1.zhimg.com/v2-59400b197e0f03d9c67db03a18df0114_720w.gif?source=d16d100b"><figcaption>图源：https://imgur.com/gallery/sHCxU</figcaption></figure><figure data-size="normal"><noscript><img src="https://picx.zhimg.com/v2-09760d72ff30c78f2be2f371dc084726_720w.gif?source=d16d100b" data-size="normal" data-rawwidth="370" data-rawheight="223" data-thumbnail="https://pic1.zhimg.com/v2-09760d72ff30c78f2be2f371dc084726_720w.jpg?source=d16d100b" class="content_image" width="370"></noscript><img src="data:image/svg+xml;utf8,&lt;svg%20xmlns='http://www.w3.org/2000/svg'%20width='370'%20height='223'&gt;&lt;/svg&gt;" data-size="normal" data-rawwidth="370" data-rawheight="223" data-thumbnail="https://pic1.zhimg.com/v2-09760d72ff30c78f2be2f371dc084726_720w.jpg?source=d16d100b" class="content_image lazy" width="370" data-actualsrc="https://picx.zhimg.com/v2-09760d72ff30c78f2be2f371dc084726_720w.gif?source=d16d100b"><figcaption>图源：https://happymag.tv/lose-your-mind-to-these-hypnotising-gifs-of-moire-patterned-vinyl-sleeves/</figcaption></figure><p data-pid="lORolNfk">更多示例也可以参考这篇文章：<a href="https://zhuanlan.zhihu.com/p/388653285" class="internal" target="_blank">脑叔：视觉幻象(三)：莫列波纹和光栅动画</a>。</p><h3>3.1 原理解析</h3><p data-pid="NiYdqSQw">其实这种动画的原理并不复杂，与上面莫列波纹的分析类似，它利用了人眼对高频图像的不敏感。这部分内容参考了文献<sup data-text="Development of Printed Animated Graphic Images Based on Optical Illusions" data-url="https://oda.oslomet.no/oda-xmlui/bitstream/handle/10642/8170/paper-published.pdf?sequence=1&amp;isAllowed=y" data-draft-node="inline" data-draft-type="reference" data-numero="8">[8]</sup>。在传统动画的基础上制作光栅动画的过程如下：</p><ol><li data-pid="hZYKzKy7">首先从动画中抽取 <img src="https://www.zhihu.com/equation?tex=k" alt="k" eeimg="1"> 帧，帧数不宜过多，那么我们的动画的周期就是 <img src="https://www.zhihu.com/equation?tex=k" alt="k" eeimg="1"> ，即每隔 <img src="https://www.zhihu.com/equation?tex=k" alt="k" eeimg="1"> 帧循环播放一次；</li><li data-pid="8doQu9hB">然后将每帧图像都通过网格进行划分，同样是 <img src="https://www.zhihu.com/equation?tex=k" alt="k" eeimg="1"> 个格子为一个周期，我们将一个周期内的格子统称为一组；</li><li data-pid="rWMlUd34">在第 <img src="https://www.zhihu.com/equation?tex=i" alt="i" eeimg="1"> 帧的每组内保留第 <img src="https://www.zhihu.com/equation?tex=i" alt="i" eeimg="1"> 个格子的图像，其余部分都涂成背景色；</li><li data-pid="DmzF9hfl">将所有帧重叠起来得到底图，因为每组内保留的格子在空间上不同，所以不会造成遮挡；</li><li data-pid="hZAB_TWT">使用缝隙宽度为1个格子，不透光的条纹宽度为 <img src="https://www.zhihu.com/equation?tex=k-1" alt="k-1" eeimg="1"> 个格子的光栅在底图上滑动即可看到动画</li></ol><p data-pid="kLg0GOLA">那么最终的效果，就是在任意时刻，光栅都刚好遮挡住了每组中的 <img src="https://www.zhihu.com/equation?tex=k-1" alt="k-1" eeimg="1"> 个格子，而刚好露出了1个格子，每组中的这1个格子必定对应同一帧图像，而光栅不透光的部分刚好填充了上面第3步删掉的部分。尽管光栅没有完全还原被删除的部分，而是显示的整个条纹，但在观看时大脑会自动加工，将各组露出的部分连在一起成为平滑的轮廓。这里图案以外的区域仍然显示的是光栅的重复条纹，而图案范围内的色块将会完全连续。连续的大段色块相对于不连续的栅格其实就是低频图像，那么从远处观看，大脑就会对这部分图像更敏感。</p><p data-pid="5V6G-bRI">如果干说很难想象，我还制作了一段演示视频，请配合食用：</p><a href="https://www.zhihu.com/zvideo/1442824755695386624" data-draft-node="block" data-draft-type="link-card"></a><p data-pid="fuRS6VnD">接下来我们分析一下哪些因素会影响动画的体验感：</p><p data-pid="4SU2jNme">1）首先，格子的宽度不能太大，否则一帧图像只留下几个格子，难以脑补出原始形状。对于小图建议先进行插值放大，然后再选取小格子，以提高图片与格子大小的比值。</p><p data-pid="deJqjnRx">1）其次，帧数不能过多。如果帧数过多，会导致 <img src="https://www.zhihu.com/equation?tex=k" alt="k" eeimg="1"> 值增大，那么光栅的不透光条纹宽度相对于缝隙宽度的比例就会很大，每帧图像只能露出很小的一部分，而剩下的都要求脑补，会看起来很难理解；</p><p data-pid="qEAp2BLT">2）但是，帧数也不能太少。否则，动画会显得不连续，有卡顿感或跳跃感；</p><p data-pid="5U0dRzyX">3）另外，动画的帧如果选取的比较合适，比较有代表性并且帧与帧之间的变化幅度不大，大脑就能够更好地还原原始动画。</p><h3>3.2 编程实现</h3><p data-pid="frCdz_9R">下面我将介绍如何编程实现任意GIF图向栅格动画的转换，完整的代码请移步GitHub仓库：<a href="http://link.zhihu.com/?target=https%3A//github.com/ThomasAtlantis/Moire" class=" wrap external" target="_blank" rel="nofollow noreferrer">Moire</a>。如何使用PS手动制作栅格动画已有诸多讨论<sup data-text="莫尔条纹动画（光栅动画）是怎样制作出来的？" data-url="https://www.zhihu.com/question/39438245/answer/387520282" data-draft-node="inline" data-draft-type="reference" data-numero="9">[9]</sup><sup data-text="《冒险小虎队》的解密卡的原理是什么？" data-url="https://www.zhihu.com/question/21650222" data-draft-node="inline" data-draft-type="reference" data-numero="10">[10]</sup>，这里我们重点讲解如何编程实现。为了讨论方便，我使用了以下黑白的动态图：</p><figure data-size="small"><noscript><img src="https://pica.zhimg.com/v2-856f9704ae5fb0d0c775cf39ce4fd52b_720w.gif?source=d16d100b" data-caption="" data-size="small" data-rawwidth="720" data-rawheight="576" data-thumbnail="https://picx.zhimg.com/v2-856f9704ae5fb0d0c775cf39ce4fd52b_720w.jpg?source=d16d100b" class="origin_image zh-lightbox-thumb" width="720" data-original="https://picx.zhimg.com/v2-856f9704ae5fb0d0c775cf39ce4fd52b_720w.jpg?source=d16d100b"></noscript><img src="data:image/svg+xml;utf8,&lt;svg%20xmlns='http://www.w3.org/2000/svg'%20width='720'%20height='576'&gt;&lt;/svg&gt;" data-caption="" data-size="small" data-rawwidth="720" data-rawheight="576" data-thumbnail="https://picx.zhimg.com/v2-856f9704ae5fb0d0c775cf39ce4fd52b_720w.jpg?source=d16d100b" class="origin_image zh-lightbox-thumb lazy" width="720" data-original="https://picx.zhimg.com/v2-856f9704ae5fb0d0c775cf39ce4fd52b_720w.jpg?source=d16d100b" data-actualsrc="https://pica.zhimg.com/v2-856f9704ae5fb0d0c775cf39ce4fd52b_720w.gif?source=d16d100b"></figure><p data-pid="zLfiaC_A">首先，我们以Python编程为例讲解实现方法。这里我们需要用到图像处理库PIL、绘图库Matplotlib以及矩阵计算库Numpy：</p><div class="highlight"><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span><span class="p">,</span> <span class="n">ImageSequence</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib.animation</span> <span class="k">as</span> <span class="nn">animation</span>
</code></pre></div><p data-pid="XXRu3cqc">定义上文中提到的动画参数：为了方便，定义光栅的缝隙宽度为1，frame_num为传入的帧数，默认为8，则光栅的缝隙和不透光条纹总宽度就等于总帧数。这里建议使用的帧数为8，你也可以尝试4~16范围内的其他值。接下来使用PIL库导入图片并进行抽帧：</p><div class="highlight"><pre><code class="language-python"><span></span><span class="c1"># GIF_file 是GIF图的存储路径</span>
<span class="n">img_it</span> <span class="o">=</span> <span class="n">ImageSequence</span><span class="o">.</span><span class="n">Iterator</span><span class="p">(</span><span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">GIF_file</span><span class="p">))</span>
<span class="n">frames</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s2">"L"</span><span class="p">))</span> <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="n">img_it</span><span class="p">]</span>
<span class="n">frames</span> <span class="o">=</span> <span class="n">frames</span><span class="p">[::</span><span class="nb">len</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span> <span class="o">//</span> <span class="n">frame_num</span><span class="p">]</span>
</code></pre></div><p data-pid="Jovva6Mi">第三行是为了得到8帧图像，由于原图总共32帧（在mac系统上直接预览就能看到），所以每隔4帧取一帧图像。这行代码要求frame_num是总帧数32的因子，否则可能不准确。大家也可以使用预览逐帧查看手动挑选关键帧，只要满足帧数等于frame_num即可。然后，我们制作底图：</p><div class="highlight"><pre><code class="language-python"><span></span><span class="n">patern</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">frames</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">index</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="nb">slice</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">frame_num</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">frame</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frames</span><span class="p">):</span> <span class="n">patern</span><span class="p">[</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="n">frame</span><span class="p">[</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span>
</code></pre></div><p data-pid="x64H4RUP">先初始化一个和每帧图像大小相同的图片，每个像素值都设为1，这里像素值是无所谓的，一会儿就会明白。然后我们遍历各帧，将第 <img src="https://www.zhihu.com/equation?tex=i" alt="i" eeimg="1"> 帧每组的第 <img src="https://www.zhihu.com/equation?tex=i" alt="i" eeimg="1"> 列拷贝到底图上，其余位置不动。我们定义函数来计算t时刻的栅格：</p><div class="highlight"><pre><code class="language-python"><span></span><span class="k">def</span> <span class="nf">card_when</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="n">card</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">patern</span><span class="p">)</span>
    <span class="n">card</span><span class="p">[:,</span> <span class="n">t</span><span class="p">::</span><span class="n">frame_num</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">card</span>
</code></pre></div><p data-pid="TYw8M4Xy">先建一个全0的与每帧图像尺寸相同的图，然后从t列开始，每隔一个周期留出一个空隙。这里其实是生成了一个二进制的掩膜，t之前都为0表示光栅的左端运行到了第t列。然后，我们使用matplotlib将图像画出来：</p><div class="highlight"><pre><code class="language-python"><span></span><span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">([])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">([])</span>
<span class="n">canvas</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">patern</span> <span class="o">*</span> <span class="n">card_when</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
</code></pre></div><p data-pid="nuhW-O7w">这里第二、三行表示去掉坐标轴，最后一行通过乘法将掩膜覆盖在底图上，这也与上文中介绍莫列波纹原理时使用的乘法相一致。光栅为0处乘完一定为0，这表示光栅遮住了这部分图案，而光栅为1处保持原图不变。接下来，使用matplotlib库的动态绘制功能：</p><div class="highlight"><pre><code class="language-python"><span></span><span class="n">animat</span> <span class="o">=</span> <span class="n">animation</span><span class="o">.</span><span class="n">FuncAnimation</span><span class="p">(</span>
    <span class="n">fig</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">canvas</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">patern</span> <span class="o">*</span> <span class="n">card_when</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="o">%</span><span class="mi">100</span><span class="p">)),</span> <span class="n">interval</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div><p data-pid="Y4nd7U9V">每隔200毫秒刷新一下画面，每次更新时重新计算掩膜的结果。这里t模上100表示t每增加到100就重新从0开始计算，也就是每隔100个t，这个动画就会重播一下，光栅就会重新从左侧开始移动。最终效果如下：</p><figure data-size="normal"><noscript><img src="https://picx.zhimg.com/v2-cac6d8a7eea4b6b60164444ebe83d8c1_720w.gif?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="370" data-rawheight="278" data-thumbnail="https://picx.zhimg.com/v2-cac6d8a7eea4b6b60164444ebe83d8c1_720w.jpg?source=d16d100b" class="content_image" width="370"></noscript><img src="data:image/svg+xml;utf8,&lt;svg%20xmlns='http://www.w3.org/2000/svg'%20width='370'%20height='278'&gt;&lt;/svg&gt;" data-caption="" data-size="normal" data-rawwidth="370" data-rawheight="278" data-thumbnail="https://picx.zhimg.com/v2-cac6d8a7eea4b6b60164444ebe83d8c1_720w.jpg?source=d16d100b" class="content_image lazy" width="370" data-actualsrc="https://picx.zhimg.com/v2-cac6d8a7eea4b6b60164444ebe83d8c1_720w.gif?source=d16d100b"></figure><p data-pid="TqA0thBX">这里的彩色感可能也是条纹太密，和显示屏产生莫列波纹的结果。在以上程序中，我们可以加入几行代码保存一下抽出的帧，然后使用HTML5的Canvas实现动画，当然你也可以直接将光栅和底图保存下来。</p><div class="highlight"><pre><code class="language-python"><span></span><span class="c1"># 保存各帧</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">frame</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ImageSequence</span><span class="o">.</span><span class="n">Iterator</span><span class="p">(</span><span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">GIF_file</span><span class="p">))):</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">frame</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="sa">f</span><span class="s2">"imgs/</span><span class="si">{GIF_name}</span><span class="s2">-</span><span class="si">{i}</span><span class="s2">.png"</span><span class="p">)</span>
        <span class="n">frames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

<span class="c1"># 保存底图</span>
<span class="n">Image</span><span class="o">.</span><span class="n">fromarray</span><span class="p">(</span><span class="mi">255</span> <span class="o">-</span> <span class="n">patern</span><span class="p">[</span><span class="mi">100</span><span class="p">:</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">250</span><span class="p">:</span><span class="o">-</span><span class="mi">250</span><span class="p">])</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s2">"L"</span><span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">'1.png'</span><span class="p">)</span>

<span class="c1"># 保存光栅的透明图像</span>
<span class="n">to_save</span> <span class="o">=</span> <span class="mi">255</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">card_when</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mi">4</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">to_save</span><span class="p">[</span><span class="n">card_when</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">Image</span><span class="o">.</span><span class="n">fromarray</span><span class="p">(</span><span class="n">to_save</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s2">"RGBA"</span><span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">'3.png'</span><span class="p">)</span>
</code></pre></div><p data-pid="btgrJWru">这里H5的编程实现原理相似，不再赘述，代码参见：<a href="http://link.zhihu.com/?target=https%3A//github.com/ThomasAtlantis/Moire/blob/master/moire.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">moire.html</a>。只有一点需要注意：在绘制实心矩形时，给定的坐标就是实际的矩形的左上角的像素位置，但绘制空心矩形，给定的位置是左上角的 <img src="https://www.zhihu.com/equation?tex=%28-1%2C-1%29" alt="(-1,-1)" eeimg="1"> 位置，即绘制的是外轮廓线。如果使用直线绘制光栅，注意线宽为1像素时存在模糊问题，参考：<a href="http://link.zhihu.com/?target=http%3A//jo2.org/html5-canvas%25E7%2594%25BB%25E5%259B%25BE3%25EF%25BC%259A1px%25E7%25BA%25BF%25E6%259D%25A1%25E6%25A8%25A1%25E7%25B3%258A%25E9%2597%25AE%25E9%25A2%2598/" class=" wrap external" target="_blank" rel="nofollow noreferrer">html5 Canvas画图3：1px线条模糊问题</a>。如果有其他问题也可以评论或私信我一起讨论。</p><h3>3.3 未来工作</h3><p data-pid="d91x3Tdj">后续的文章可能致力于解决以下问题：</p><ol><li data-pid="JmfEzqFU">基于莫列波纹的动画其实还有很多变体：1）彩色动画；2）网格光栅；3）旋转滑动或透视改变。这些变体在本文中没有讨论，但在本文给出的示例图或参考网站中有所提及。可以探索这些变体的原理，并对比不同变体的优势与不足。</li><li data-pid="YRjPWge4">如何提升观感还需要更严谨的探索，本文只简单讨论了动画帧数、光栅缝隙大小、图像大小等影响观感的因素，但没有给出通用的提升观感的方法。由于帧数（流畅性）与光栅粒度（完整性）是一对矛盾的参数，可能需要新方法来重新设计光栅的纹理形状、颜色以及滑动方式，以同时提高二者。相信百年以来已有研究者给出了相关分析。</li><li data-pid="bMoCYg7e">可以做一个GIF图导出底图的在线网站，辅助计算A4纸上的图像条纹大小。配套的可以提供一些相机蒙版作为光栅，让用户使用手机摄像头就可以预览动画。这个网站<a href="http://link.zhihu.com/?target=https%3A//www.giannisarcone.com/Kinegrams.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">Gianni Sarcone's Kinetic Art</a>虽然也提供了在线交互式预览的功能，但网站本身只收录了站长自己的作品，不是一个开源的生态。</li><li data-pid="vwHz2to_">本文没有探讨莫列波纹对一般图像或文字的加密、解密方法，冒险小虎队的题图只为引入莫列波纹现象，可能产生一定的误导。有时间细读mQRcode那篇文章[1]，以及那本极厚的参考书[7]，同样可以制作一个利用莫列波纹在线加密解密的网站。</li></ol><h2>4 其他</h2><p data-pid="bA_eno1A">大家可能会好奇我如何制作的演示视频。这个视频完全使用Python编写，代码已开源：<a href="http://link.zhihu.com/?target=https%3A//github.com/ThomasAtlantis/Moire/blob/master/manim_moire.py" class=" wrap external" target="_blank" rel="nofollow noreferrer">manim_moire.py</a>，使用的是由3b1b创造的数学视频演示框架Manim，现在已经由社区共同维护：<a href="http://link.zhihu.com/?target=https%3A//www.manim.community/" class=" wrap external" target="_blank" rel="nofollow noreferrer">Manim Community</a>。</p><p data-pid="CRYY0G_r">我2019年的时候在CSDN上写过一篇文章：<a href="http://link.zhihu.com/?target=https%3A//blog.csdn.net/shanchenglang/article/details/103581014%3Fspm%3D1001.2014.3001.5501" class=" wrap external" target="_blank" rel="nofollow noreferrer">弹性碰撞次数与圆周率的关系 - 3Blue1Brown</a>，文末介绍了3b1b这个才华横溢的小哥。从那时起我就格外关注Manim这个框架，它完全使用代码来合成动画，是一种非常精确稳定的视频剪辑方法。其中有很多预设的图形和动效，可以使很多语言难以解释的数学问题变得通俗易懂。我当时就想，其实也不只是数学需要这种演示，计算机科普同样需要啊，然而很多计算机需要的图形和动效它却没有很好地封装。那时的Manim框架在国内还鲜有人知，我分析了它的几个大的问题：</p><ol><li data-pid="PrzIOpVd">它文档极其简陋，很多函数需要自己去3b1b的视频源代码中手动搜索，用法多一半靠猜；</li><li data-pid="jngPFp-f">它的代码相当冗余，一个20分钟的视频可能就需要5000行以上的代码；</li><li data-pid="CDm-Mw9K">它的报错很难调试，因为视频渲染是很耗时的，而且动画对上下文具有依赖性，不能针对某行代码进行单独测试；</li></ol><p data-pid="FFrE9YV_">我当时就联合实验室的几个兄弟想要搞国产的计算机领域的Manim，想要使用Canvas对其进行重写，但后来分析这件事，发现投入巨大产出稀少不值得去做，所以就搁置了下来。我当时构想使用JS做Manim不仅仅是因为Canvas原生就支持动画，更因为H5完善的生态，图形渲染上从底层WebGL到上层three.js都很成熟。生成的图形结果可以在网页上直接调试，更能加入与用户的交互功能。而后端本身得益于node.js也可以使用JS统一编写，如果有一份代码，能同时自动化生成视频、文章、可交互控件的不同版本，这将是多媒体生产工具演进的里程碑。</p><p data-pid="qjo2a-IL">后来我查看3b1b的官网时发现他的做法与我的想法不谋而合。大家可以在介绍神经网络的这篇文章处体验一下：<a href="http://link.zhihu.com/?target=https%3A//www.3blue1brown.com/lessons/neural-networks" class=" wrap external" target="_blank" rel="nofollow noreferrer">3Blue1Brown - But what is a Neural Network?</a>。这篇文章绝不会是单独编写的，一定有自动化的框架使得他的代码在生成视频的时候也生成了这个网页。其中交互控件完全使用矢量图绘制，每个图形一定是可复用的模块，看来他是有备而来。</p><p data-pid="aV2930_W">实际上，我交大的博士同学<a href="http://link.zhihu.com/?target=https%3A//www.icerdesign.com/about.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">冰河魔法师</a>，已经创办了将视频自动转换为图文的公司，大家可以体验一下他的产品：<a href="http://link.zhihu.com/?target=https%3A//www.editool.cn/" class=" wrap external" target="_blank" rel="nofollow noreferrer">剪刀兔</a>。正所谓不用剪刀兔，视频剪到吐哈哈哈哈。我和他也聊过多媒体生产工具的未来，在某些事情上总是英雄所见略同。希望这类工具的生态快快发展，毕竟，这就是未来啊！</p><p data-pid="sHm15Czr">另外，视频中的配音完全使用百度AI语音合成。我提供了一个爬取这个API的小例子：<a href="http://link.zhihu.com/?target=https%3A//github.com/ThomasAtlantis/Moire/blob/master/text2sound.py" class=" wrap external" target="_blank" rel="nofollow noreferrer">text2sound.py</a>。这个程序会将文字转换为base64编码的音频，然后可以在这个网站上解码得到mp3文件：<a href="http://link.zhihu.com/?target=https%3A//base64.guru/converter/decode/audio" class=" wrap external" target="_blank" rel="nofollow noreferrer">Base64 to Audio</a>。网站在解码之后会给出音频时长，然后在视频代码中只需插入两行代码就可以完成配音：</p><div class="highlight"><pre><code class="language-python"><span></span><span class="bp">self</span><span class="o">.</span><span class="n">add_sound</span><span class="p">(</span><span class="s2">"1.mp3"</span><span class="p">)</span> <span class="c1"># 音频路径为1.mp3时</span>
<span class="bp">self</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>            <span class="c1"># 音频时长为5s时</span>
</code></pre></div><p data-pid="tF0rDsxq">这个视频代码框架以及自动配音可能需要进一步整合，未来如果有时间我也许会出一期专门介绍视频编程的文章。</p>