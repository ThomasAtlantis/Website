<h2><b>1 重复释放问题</b></h2><p data-pid="5CgKoVHw">感谢<a href="http://link.zhihu.com/?target=https%3A//blog.csdn.net/RadiumTang" class=" wrap external" target="_blank" rel="nofollow noreferrer">我的室友</a>在项目开发时遇到了这个百思不得其解的BUG：<a href="http://link.zhihu.com/?target=https%3A//blog.csdn.net/RadiumTang/article/details/118661438" class=" wrap external" target="_blank" rel="nofollow noreferrer">Double Free与不起眼的拷贝构造函数</a>。我们一起研究了一下，在此记录下来以防患于未然。</p><h3>1.1 问题描述</h3><p data-pid="Rc9-DQuR">我们平时在使用类似<code>vector</code>这样的容器时，会习惯性地使用<code>push_back</code>操作去添加一个元素。当这个元素是一个类的实例，并且在类中定义了一个指针成员变量用来指向动态开辟的内存时，就会出现致命的指针重复释放问题。我们看一下效果：</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">*</span> <span class="n">name</span><span class="p">;</span>
    <span class="n">Point</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span><span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">name</span><span class="p">(</span><span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="p">{}</span>
    <span class="o">~</span><span class="n">Point</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">name</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Point</span> <span class="n">p1</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"origin"</span><span class="p">);</span>
    <span class="n">Point</span> <span class="n">p2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"x1"</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">points</span><span class="p">;</span>
    <span class="n">points</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span>
    <span class="n">points</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">p</span><span class="p">:</span> <span class="n">points</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p data-pid="IS2sL1Jz">CLion中编译执行后输出结果如下：</p><div class="highlight"><pre><code class="language-text"><span></span>x1
Test(47888,0x11573ce00) malloc: *** error for object 0x7fbe08405a00: pointer being freed was not allocated
Test(47888,0x11573ce00) malloc: *** set a breakpoint in malloc_error_break to debug
</code></pre></div><p data-pid="0oX2ObKH">在调用vector的push_back函数时会自动地将传入的对象拷贝构造一份新的压入容器中，那么在程序执行到main函数的<code>}</code> 时就会启动垃圾回收机制，释放p1和p2的时候分别调用了它们的析构函数对name进行释放。但在points调用析构函数的时候又会逐个析构容器内的对象。而容器内的对象是拷贝构造生成的，浅拷贝机制使得它们的name指向的空间和p1、p2的一致，这些空间已被释放，再次释放就出现了重复释放的BUG。</p><h3>1.2 解决方案</h3><p data-pid="iSIqy4nI"><b>1.3.1 使用emplace_back</b></p><p data-pid="OVG-a9NB">在这个语境下，我们可以简单地使用emplace_back去替换push_back的功能。前者可以直接传入构造函数的参数进行一次构造，而不需要拷贝。我们可以将主函数中的内容替换如下：</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">points</span><span class="p">;</span>
<span class="n">points</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">points</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"origin"</span><span class="p">);</span>
<span class="n">points</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"x1"</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">p</span><span class="p">:</span> <span class="n">points</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p data-pid="uRt68oql">注意我们需要使用reserve预留两个元素的空间，否则由于vector动态调整空间大小，第一次emplace_back没有问题，它只开辟一个元素的空间，当再次加入元素，它会开辟一个更大的空间并将第一个元素拷贝进去，就又会调用拷贝构造函数，就又出现指针重复释放。</p><p data-pid="PfNVV0ow">可见我们在实际开发中很难避免这种类的拷贝构造，实际上以下两种代码一样会出错：</p><p data-pid="rhk09d6i">#1 容器的初始化会进行拷贝构造</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="n">Point</span> <span class="nf">p1</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"origin"</span><span class="p">);</span>
<span class="n">Point</span> <span class="nf">p2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"x1"</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">points</span><span class="p">{</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">};</span>
</code></pre></div><p data-pid="rDL88KUJ">#2 直接拷贝</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="n">Point</span> <span class="nf">p1</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"origin"</span><span class="p">);</span>
<span class="n">Point</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>
</code></pre></div><p data-pid="jKMpc8oN">我们如果不在析构函数中定义delete那么必将造成内存泄露，如果我们定义一个拷贝构造函数来深拷贝，那么时空效率就会下降。解决这个问题的真正方法，就是使用新特性：<b>智能指针！</b></p><p data-pid="tPnCHTfD">参考：<a href="http://link.zhihu.com/?target=https%3A//www.cnblogs.com/WindSun/p/11444429.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">详解C++11智能指针</a>，智能指针其实可以自己实现，在我还没接触到C++11的时候就见到过某些ACM的队友自己编写智能指针对象了。智能指针的智能首先就体现在，它不需要你去显示地delete，它作为储存在栈中的局部变量，在析构时会自动对它管理的堆空间进行释放。</p><p data-pid="IZkB3fmq"><b>1.3.2 使用unique_ptr</b></p><p data-pid="STfzLCF4">unique_ptr使用独占式拥有或严格拥有概念，保证同一时间只能有一个智能指针指向该堆空间。也就是说它不允许在声明之后将另一个指针对象直接赋值给它：</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">p3</span> <span class="p">(</span><span class="k">new</span> <span class="n">string</span> <span class="p">(</span><span class="s">"auto"</span><span class="p">));</span>
<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">p4</span><span class="p">;</span>
<span class="n">p4</span> <span class="o">=</span> <span class="n">p3</span><span class="p">;</span>  <span class="c1">// Invailid</span>
</code></pre></div><p data-pid="WMv-6lHg">这就在编译期间避免了拷贝构造的问题，如果将最上面代码中的指针换成unique_ptr，那么当编译检测到拷贝构造的时候会直接报错，比如下面这段代码：</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">name</span><span class="p">;</span>
    <span class="n">Point</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span><span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">name</span><span class="p">(</span><span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="p">{}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Point</span> <span class="n">p1</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"origin"</span><span class="p">);</span>
    <span class="n">Point</span> <span class="n">p2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"x1"</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">points</span><span class="p">;</span>
    <span class="n">points</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span>
    <span class="n">points</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p data-pid="0pUwOU0g">编译提示如下错误：</p><div class="highlight"><pre><code class="language-text"><span></span>error: call to implicitly-deleted copy constructor of 'Point'
...
copy constructor is implicitly deleted because 'unique_ptr&lt;std::__1::basic_string&lt;char&gt;, std::__1::default_delete&lt;std::__1::basic_string&lt;char&gt; &gt; &gt;' has a user-declared move constructor
</code></pre></div><p data-pid="-D4gM0fQ">由于unique_ptr不允许拷贝构造，编译器在编译期间将Point的拷贝构造函数删除了，然而push操作中会尝试对Point对象拷贝，所以报错。unique_ptr不能直接赋值，但是可以使用std::move来转移所有权，我们将上面代码的push改为下面这样就可以正常运行了：</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="n">points</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">p1</span><span class="p">));</span>
<span class="n">points</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">p2</span><span class="p">));</span>
</code></pre></div><p data-pid="0c2ZUyTv">因为move避免了对p1、p2的拷贝构造，自然也就避免了对成员变量unique_ptr的拷贝。但是我们尝试使用以下方式push_back，程序也可以正确执行：</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">points</span><span class="p">;</span>
<span class="n">points</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"origin"</span><span class="p">));</span>
<span class="n">points</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"x1"</span><span class="p">));</span>
</code></pre></div><p data-pid="IcT9ji_o">这是由于vector在实现时定义了移动构造函数，括号内的对象被认为是临时右值，所以触发了vector内部的move操作，效果和上一段代码相同。</p><p data-pid="EOsVZQzX">另外当源unique_ptr为临时右值时，智能指针本身也是支持移动构造的：</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">pu3</span><span class="p">;</span> 
<span class="n">pu3</span> <span class="o">=</span> <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span> <span class="p">(</span><span class="s">"You"</span><span class="p">));</span>   <span class="c1">// valid</span>
</code></pre></div><p data-pid="QEAqJeh4">但这个机制也就导致了下面这个漏洞：</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre></div><p data-pid="x_XcdnQX">这段代码成功地利用临时右值的漏洞，将两个unique_ptr指向了同一个堆空间，所以又造成了重复释放的BUG。我舍友问我这个unique_ptr和常指针有什么区别，咳咳，首先常指针不智能啊，你需要记得释放，当然它也解决不了今天的问题，因为常指针也是运行拷贝构造函数进行赋值的呀（利用初始化参数列表）。系统会自动生成以下拷贝构造函数：</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="n">Point</span><span class="p">(</span><span class="k">const</span> <span class="n">Point</span> <span class="o">&amp;</span> <span class="n">point</span><span class="p">)</span><span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="n">point</span><span class="p">.</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="n">point</span><span class="p">.</span><span class="n">y</span><span class="p">),</span> <span class="n">name</span><span class="p">(</span><span class="n">point</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="p">{}</span>
</code></pre></div><p data-pid="Ltpca3Yb">那么一样会造成指针重复释放。另外值得一提的是常指针不像unique_ptr，它不允许不进行初始化，即野指针：</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">*</span> <span class="k">const</span> <span class="n">name</span><span class="p">;</span>  <span class="c1">// invalid</span>
</code></pre></div><p data-pid="kds3sLYv"><b>1.3.3 使用shared_ptr</b></p><p data-pid="oG5xDabp">看起来unique_ptr也存在诸多缺陷，C++11还提供了共享式拥有的智能指针shared_ptr。多个智能指针可以指向相同对象，该对象和其相关资源会在「最后一个引用被销毁」时释放：使用计数机制来表明资源被几个指针共享，当它析构时会释放资源所有权，所有指向该资源的指针计数减一，当计数等于0时，资源本身会被delete掉。</p><p data-pid="S5bWAKkW">这个方法完美地解决我们的问题：</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">name</span><span class="p">;</span>
    <span class="n">Point</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span><span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">name</span><span class="p">(</span><span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Point</span> <span class="n">p1</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">"origin"</span><span class="p">);</span>
    <span class="n">Point</span> <span class="n">p2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"x1"</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">points</span><span class="p">;</span>
    <span class="n">points</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span>
    <span class="n">points</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p data-pid="TfXACRP0">因为拷贝构造函数进行浅拷贝时，新的对象的shared_ptr指向同一个资源，导致计数值变为2，那么两个对象分别析构时调用两次智能指针的析构，最后一个指针析构时检测到计数值变为0，将资源释放掉。</p><h2>2 循环引用问题</h2><p data-pid="-zMVpc51">那么是不是使用shared_ptr就完全没问题了呢？并不是。</p><h3>2.1 问题描述</h3><p data-pid="fi2mxGLo">当两个类A和B分别定义了类型为B和A的指针成员变量pb和pa，实例化两个对象的指针a和b，使a.pb指向b，b.pa指向a。假如所有的指针我们都使用共享指针来实现，我们会发现在该局部代码段执行完毕进行垃圾回收时：调用指针a的析构函数，发现计数值还剩1，不能释放这个对象；由于这个对象没有释放，pb没被释放，所以调用指针b的析构函数时也发现计数值还剩1，也不能释放指向的对象。这时程序员可能以为他们都被释放了，指针a和b很有可能被赋予新值，这时a和b指向的对象实际没有被释放掉，就永远不能被找到了，这就导致了内存泄露。这个过程的伪代码表示如下：</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="k">class</span> <span class="nc">A</span><span class="o">:</span> <span class="n">shared_ptr</span> <span class="n">pb</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">B</span><span class="o">:</span> <span class="n">shared_ptr</span> <span class="n">pa</span><span class="p">;</span>
<span class="n">shared_ptr</span> <span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">();</span> 
<span class="n">shared_ptr</span> <span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="p">();</span>
<span class="n">a</span><span class="p">.</span><span class="n">pb</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span> <span class="n">b</span><span class="p">.</span><span class="n">pa</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
<span class="n">destruct</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
</code></pre></div><h3>2.2 解决方案</h3><p data-pid="mZgCHvNX">C++11引入了弱指针类型weak_ptr，它指向某个资源时，不会引起shared_ptr的计数值增加。那么我们只需要将以上类定义中的两个shared_ptr中的一个替换为weak_ptr就可以避免这种循环引用的死锁了。假如说改为以下：</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="k">class</span> <span class="nc">A</span><span class="o">:</span> <span class="n">shared_ptr</span> <span class="n">pb</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">B</span><span class="o">:</span> <span class="n">weak_ptr</span> <span class="n">pa</span><span class="p">;</span>
</code></pre></div><p data-pid="YM37h0n6">那么程序执行完毕，在析构前B对象的引用计数值为2，而A对象的计数值为1。析构指针a时，A对象的计数值减为0，释放资源，调用A对象的析构函数，析构pb，导致B对象的计数值减为1；析构指针b时，B对象的计数值减为0，对象B被释放。</p><p data-pid="SjUaYfJ_">弱指针的初始化比较麻烦：</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="c1">// invalid</span>
<span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">(</span><span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">"hello"</span><span class="p">));</span>

<span class="c1">// valid</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">tmp</span><span class="p">(</span><span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">"hello"</span><span class="p">));</span>
<span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
</code></pre></div><p data-pid="ler0XkLe">获取弱指针指向的内容需要先进行转换：</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">lock</span><span class="p">());</span>
</code></pre></div><p data-pid="W8qezs8H">弱指针的lock()方法会返回一个shared_ptr指针，然后取内容即可。</p>