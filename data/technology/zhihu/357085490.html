<h2>1 写在前面</h2><p data-pid="T4deGPUH">之前为了方便打谱寻找步数，做了一些围棋棋谱识别的实验「<a href="https://zhuanlan.zhihu.com/p/347539186" class="internal" target="_blank">围棋棋谱扫描工具开发实验</a>」，知友们期待我能继续做下去。恰逢晚上课程讲的内容已经学过了，百无聊赖趁机继续推进一步。在上一篇文章中，我实现了对纸质棋谱照片中步数的识别，可以可视化地辅助找到当前步或指定步的位置。但是我最初的设想是，能够<b>将纸质棋谱直接变为可控制的电子棋谱</b>，比如说业界常用的SGF，这样就完全实现了棋谱的无纸化。为了实现这个功能，我们需要<b>得到每步棋在棋盘坐标系下的坐标</b>。同时，知友希望能<b>实现对PDF扫描文件的识别</b>，当然这其实比照片还要简单。</p><p data-pid="PWKcKbVh">然而经过一番搜索，发现很难找到合适的图片数据。在这些扫描件里面，要么是80年代以前发黄的老书，棋盘线和数字都残缺不全；要么是对局精解，一局棋被拆分成多个谱子，每个谱子并没有多少手数，完全没有识别的必要。除此之外，网上早已涌现了大量的电子棋谱分享网站和论坛，中国依仗网民数量优势，几乎已经实现了棋谱的无纸化，所以这件事的现实需求可能并不大，是我在这里炒冷饭了。当然这件事在以前还是有意义的，众所周知<a href="http://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%25E5%259B%25B4%25E6%25A3%258B%25E5%25A4%25A9%25E5%259C%25B0/840435%3Ffr%3Daladdin" class=" wrap external" target="_blank" rel="nofollow noreferrer">围棋天地</a>每刊都有几张全局记在一页上的谱子。下面记录实验，技术性并不是很强，为这个主题画个句号。</p><figure data-size="normal"><noscript><img src="https://picx.zhimg.com/v2-13e74b0760a22b10d2e33ef512ba4f7f_720w.jpg?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="1679" data-rawheight="539" class="origin_image zh-lightbox-thumb" width="1679" data-original="https://picx.zhimg.com/v2-13e74b0760a22b10d2e33ef512ba4f7f_720w.jpg?source=d16d100b"></noscript><img src="data:image/svg+xml;utf8,&lt;svg%20xmlns='http://www.w3.org/2000/svg'%20width='1679'%20height='539'&gt;&lt;/svg&gt;" data-caption="" data-size="normal" data-rawwidth="1679" data-rawheight="539" class="origin_image zh-lightbox-thumb lazy" width="1679" data-original="https://picx.zhimg.com/v2-13e74b0760a22b10d2e33ef512ba4f7f_720w.jpg?source=d16d100b" data-actualsrc="https://picx.zhimg.com/v2-13e74b0760a22b10d2e33ef512ba4f7f_720w.jpg?source=d16d100b"></figure><p data-pid="vUCM0iFe">a) <a href="http://link.zhihu.com/?target=https%3A//www.101weiqi.com/" class=" wrap external" target="_blank" rel="nofollow noreferrer">101围棋网</a>收录的电子棋谱 b) 字迹模糊的老书「忘忧清乐集」中的「呕血谱」 c) 单页手数不多的吴清源对局精解</p><h2>2 实验过程</h2><p data-pid="EGUs3eC2">为了演示算法过程，我使用<a href="http://link.zhihu.com/?target=http%3A//sinago.com/gibo/new_gibo.asp%3Fcur_page%3D0" class=" wrap external" target="_blank" rel="nofollow noreferrer">新浪围棋棋谱</a>网站的打印功能，将电子棋谱转换为PDF格式来模拟扫描文件的截图。可以看到，这张图片的清晰度很高，也不会出现纸质谱拍照时的畸变和光线问题。为了得到每步棋的棋盘坐标，首先我们要把坐标系建立起来，这就需要识别每个交叉点的位置，首先需要识别棋盘的十九路棋盘线。</p><figure data-size="normal"><noscript><img src="https://picx.zhimg.com/v2-92f3b8eb9bcf6327a61edd161a6aa425_720w.jpg?source=d16d100b" data-size="normal" data-rawwidth="1089" data-rawheight="1080" class="origin_image zh-lightbox-thumb" width="1089" data-original="https://pic1.zhimg.com/v2-92f3b8eb9bcf6327a61edd161a6aa425_720w.jpg?source=d16d100b"></noscript><img src="data:image/svg+xml;utf8,&lt;svg%20xmlns='http://www.w3.org/2000/svg'%20width='1089'%20height='1080'&gt;&lt;/svg&gt;" data-size="normal" data-rawwidth="1089" data-rawheight="1080" class="origin_image zh-lightbox-thumb lazy" width="1089" data-original="https://pic1.zhimg.com/v2-92f3b8eb9bcf6327a61edd161a6aa425_720w.jpg?source=d16d100b" data-actualsrc="https://picx.zhimg.com/v2-92f3b8eb9bcf6327a61edd161a6aa425_720w.jpg?source=d16d100b"><figcaption>2020围甲联赛季后赛，黑：朴廷桓，白：李钦诚</figcaption></figure><p data-pid="2AQ-Xum-">我们使用霍夫线变换检测直线，这个方法的原理已经在上一篇文章中介绍过，这里补充一些算法细节。之前提到，该方法将直角坐标系下的点变换成为极坐标系中的曲线后，计算曲线两两之间的交点。根据交点的数量进行投票，数量超过阈值的交点的坐标作为直线的参数返回。然而，在实际应用中直接计算交点坐标的解析解将耗时耗力，可以采用数值方法进行估计。</p><p data-pid="x0d4H0f2">我们将极坐标系划分成网格，对 <img src="https://www.zhihu.com/equation?tex=%5Crho" alt="\rho" eeimg="1"> 轴和 <img src="https://www.zhihu.com/equation?tex=%5Ctheta" alt="\theta" eeimg="1"> 轴分别按照指定的固定步长进行切割。对于每个像素点对应的极坐标曲线，沿着 <img src="https://www.zhihu.com/equation?tex=%5Ctheta" alt="\theta" eeimg="1"> 轴每隔一个小格的宽度对曲线进行一次采样，所得的采样点落在某个小格内，便使该小格的记数器加一。当直角坐标中全部的点都变换后，对小格进行逐个检验，计数值超过投票阈值的小格，其中心点的 <img src="https://www.zhihu.com/equation?tex=%5Crho" alt="\rho" eeimg="1"> 值和 <img src="https://www.zhihu.com/equation?tex=%5Ctheta" alt="\theta" eeimg="1"> 值作为检测到的直线的参数返回。</p><p data-pid="yZ-gOrEq">除了以上数值方法，霍夫变换还可以进行多尺度的改进。标准霍夫变换有两个比较有名的变体：1986年的<u><a href="http://link.zhihu.com/?target=https%3A//www.sciencedirect.com/science/article/pii/0734189X86900733" class=" wrap external" target="_blank" rel="nofollow noreferrer">Fast Hough transform: A hierarchical approach</a>和</u>1987年的<a href="http://link.zhihu.com/?target=https%3A//ieeexplore.ieee.org/abstract/document/4767964" class=" wrap external" target="_blank" rel="nofollow noreferrer">Adaptive Hough Transform</a>，分别具有433和786的引用量。前者将参数空间划分成从粗到细多层次粒度的超立方体小格子，进行多轮迭代逐步细化，每次只关注投票数超过阈值的小格子；后者则使用一个累计数组先粗糙地计数，再按照某种方法寻找Peak，然后在Peak附近进行更细粒度的划分和计数，以提升检测到的直线的参数精确度。</p><p data-pid="hNKT9gii">Python的OpenCV为我们提供的接口如下，参考<a href="http://link.zhihu.com/?target=http%3A//www.opencv.org.cn/opencvdoc/2.3.2/html/modules/imgproc/doc/feature_detection.html%3Fhighlight%3Dhough%23cv2.HoughLines" class=" wrap external" target="_blank" rel="nofollow noreferrer">OpenCV官方文档</a>。</p><div class="highlight"><pre><code class="language-python"><span></span><span class="n">cv2</span><span class="o">.</span><span class="n">HoughLines</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">threshold</span><span class="p">[,</span> <span class="n">lines</span><span class="p">[,</span> <span class="n">srn</span><span class="p">[,</span> <span class="n">stn</span><span class="p">]]])</span> 
</code></pre></div><p data-pid="vPlQHycp">霍夫线变换函数的参数表如下：</p><table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><th>image</th><td>经过边缘检测后的二值化图像</td></tr><tr><th>rho</th><td>极坐标参数rho的精度</td></tr><tr><th>theta</th><td>极坐标参数theta的精度</td></tr><tr><th>threshold</th><td>交点的最小投票数</td></tr><tr><th>lines</th><td>储存检测结果的返回值，为了和C语言接口保持一致，一般不使用</td></tr><tr><th>srn</th><td>多尺度霍夫变换中rho缩小的比例</td></tr><tr><th>stn</th><td>多尺度霍夫变换中theta缩小的比例</td></tr></tbody></table><p data-pid="T6KKfM6_">这里image是输入的图片，要求经过边缘检测和二值化，这个过程通常可以使用上篇文章提到的Canny法进行处理，我们一会儿介绍它的函数接口。rho表示极坐标参数 <img src="https://www.zhihu.com/equation?tex=%5Crho" alt="\rho" eeimg="1"> 的精度，源码中可以发现 <img src="https://www.zhihu.com/equation?tex=%5Crho" alt="\rho" eeimg="1"> 轴被划分成 <img src="https://www.zhihu.com/equation?tex=%5Csqrt%7Bw%5E2%2Bh%5E2%7D%2Frho" alt="\sqrt{w^2+h^2}/rho" eeimg="1"> 个小段。theta表示参数 <img src="https://www.zhihu.com/equation?tex=%5Ctheta" alt="\theta" eeimg="1"> 的精度，源码中 <img src="https://www.zhihu.com/equation?tex=%5Ctheta" alt="\theta" eeimg="1"> 被划分成 <img src="https://www.zhihu.com/equation?tex=2%5Cpi%2Ftheta" alt="2\pi/theta" eeimg="1"> 个小段。源码请参考：<a href="http://link.zhihu.com/?target=https%3A//github.com/cybertk/opencv/blob/master/opencv/cv/src/cvhough.cpp" class=" wrap external" target="_blank" rel="nofollow noreferrer">GitHub传送门</a>。</p><p data-pid="q-UDOTpy">OpenCV中的多尺度霍夫变换其实是根据上面提到的AHT那篇文章或者那篇文章的后续工作实现的。强烈谴责网上诸多博主不求甚解的学习态度，都以讹传讹说这叫做MSHT，怕不是自己起的名字。并且网上没有任何文章讲解了所谓MSHT算法的细节，也没有任何文章讲解了这部分的源码，所以说大家就是互相转载、能用就行，谁也没研究过原理。这部分算法大体思想与AHT一致，但只使用了两个阶段，并且没有重用计数器数组（优化的失败）。第一个阶段使用了很奇怪的公式计算粗粒度的结果，如果达到阈值的格子数量超过格子总数的百分之一，就改用SHT从头计算，否则继续进行第二阶段。第二个阶段对超过投票阈值的区域使用类似SHT的算法计算更精确的参数值，srn和stn就是第二阶段小格子的尺寸。实际上OpenCV这段代码还存在一些优化不到位和冗余的代码，大家可以自行探索。</p><p data-pid="WZSGjDMN">这个函数返回一个列表lines，列表中每个元素line表示一条直线，line[0]是一个二元组，分别为直线的参数 <img src="https://www.zhihu.com/equation?tex=%5Crho" alt="\rho" eeimg="1"> 和 <img src="https://www.zhihu.com/equation?tex=%5Ctheta" alt="\theta" eeimg="1"> 。</p><p data-pid="LNuTXGCa">OpenCV中给出Canny法边缘检测的函数接口如下：</p><div class="highlight"><pre><code class="language-python"><span></span><span class="n">cv2</span><span class="o">.</span><span class="n">Canny</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">threshold1</span><span class="p">,</span> <span class="n">threshold2</span><span class="p">[,</span> <span class="n">edges</span><span class="p">[,</span> <span class="n">apertureSize</span><span class="p">[,</span> <span class="n">L2gradient</span> <span class="p">]]])</span>
</code></pre></div><p data-pid="aive9ESA">这里image是待检测边缘的单通道（灰度）图片。threshold是双阈值筛选用到的低阈值和高阈值。edges是边缘检测后输出的图片，为了和C++的实现保持一致，一般不使用。apertureSize是sobel算子的模板大小。sobel算子对灰度渐变或噪声较多的图片的检测效果较好。其模板大小可以取值3、5、7，经验表明数字越大保留的细节和噪声越多，我们一般使用3。L2gradient表明是否采用更精确的方式计算图像梯度。</p><p data-pid="ibif5-XJ">接下来我们尝试使用霍夫法检测棋谱图片中的直线：</p><div class="highlight"><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">cv2</span>
<span class="n">src</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="s2">"./test.jpg"</span><span class="p">)</span>
<span class="n">gray</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>
<span class="n">edges</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">Canny</span><span class="p">(</span><span class="n">gray</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">apertureSize</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">lines</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">HoughLines</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
    <span class="n">rho</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">rho</span>
    <span class="n">y0</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">rho</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x0</span> <span class="o">-</span> <span class="mi">2000</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span><span class="p">))</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">y0</span> <span class="o">-</span> <span class="mi">2000</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span><span class="p">))</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x0</span> <span class="o">+</span> <span class="mi">2000</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span><span class="p">))</span>
    <span class="n">y2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">y0</span> <span class="o">+</span> <span class="mi">2000</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span><span class="p">))</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">gray</span><span class="p">,</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">80</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">gray</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">'gray'</span><span class="p">)</span>
</code></pre></div><p data-pid="R0sN4d5r">我看到网上有人问那个2000是什么东西，这其实是根据极坐标转直角坐标的直线公式，计算出来的两个很远的端点，为了保证直线穿过整个图片，所以选用了一个比较大的系数。</p><p data-pid="GY4jYvUw"><img src="https://www.zhihu.com/equation?tex=%5Cleft%5C%7B+%5Cbegin%7Baligned%7D+x++%26%3D+%28%5Crho+-+t%29+%5Ccos+%5Ctheta+%5C%5C+y++%26%3D+%28%5Crho+%2B+t%29%5Csin+%5Ctheta++%5Cend%7Baligned%7D+%5Cright.%5C%5C" alt="\left\{ \begin{aligned} x  &amp;= (\rho - t) \cos \theta \\ y  &amp;= (\rho + t)\sin \theta  \end{aligned} \right.\\" eeimg="1"> </p><p data-pid="811iIZVa">参考上篇文章，以上公式可以满足 <img src="https://www.zhihu.com/equation?tex=x%5Ccos%5Ctheta%2By%5Csin%5Ctheta%3D%5Crho" alt="x\cos\theta+y\sin\theta=\rho" eeimg="1"> ，那么 <img src="https://www.zhihu.com/equation?tex=%28x_0%2Cy_0%29" alt="(x_0,y_0)" eeimg="1"> 即为 <img src="https://www.zhihu.com/equation?tex=t%3D0" alt="t=0" eeimg="1"> 时的点，而 <img src="https://www.zhihu.com/equation?tex=%28x_1%2C+y_1%29" alt="(x_1, y_1)" eeimg="1"> 和 <img src="https://www.zhihu.com/equation?tex=%28x_2%2Cy_2+%29" alt="(x_2,y_2 )" eeimg="1"> 分别为 <img src="https://www.zhihu.com/equation?tex=t%3D-2000" alt="t=-2000" eeimg="1"> 和 <img src="https://www.zhihu.com/equation?tex=t%3D2000" alt="t=2000" eeimg="1"> 时的点。使用line函数将检测出的图片绘制在原图上，可以发现我们丢掉了很多需要被检测到的棋盘线。</p><figure data-size="normal"><noscript><img src="https://pica.zhimg.com/v2-8d8f751aada0b0d4ac66751e80c27a66_720w.jpg?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="1324" data-rawheight="1274" class="origin_image zh-lightbox-thumb" width="1324" data-original="https://pic1.zhimg.com/v2-8d8f751aada0b0d4ac66751e80c27a66_720w.jpg?source=d16d100b"></noscript><img src="data:image/svg+xml;utf8,&lt;svg%20xmlns='http://www.w3.org/2000/svg'%20width='1324'%20height='1274'&gt;&lt;/svg&gt;" data-caption="" data-size="normal" data-rawwidth="1324" data-rawheight="1274" class="origin_image zh-lightbox-thumb lazy" width="1324" data-original="https://pic1.zhimg.com/v2-8d8f751aada0b0d4ac66751e80c27a66_720w.jpg?source=d16d100b" data-actualsrc="https://pica.zhimg.com/v2-8d8f751aada0b0d4ac66751e80c27a66_720w.jpg?source=d16d100b"></figure><p data-pid="sX54vkxJ">这是由于某些行和列棋子较多，裸露出来的棋盘线并不连贯，所以投票时票数未能达到阈值。我们可以尝试基于概率的霍夫变换寻找直线的片段，使用HoughLinesP函数。但是考虑到极端情况下，某一行或列可能完全被棋子覆盖，这种方法也将失效。这时我们采用一种很简单的小技巧，即结合圆检测的结果，将棋子涂白，并补上遮挡的交叉点。</p><figure data-size="normal"><noscript><img src="https://picx.zhimg.com/v2-d3de3e0fc972950e032bb98a847ad00d_720w.jpg?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="661" data-rawheight="641" class="origin_image zh-lightbox-thumb" width="661" data-original="https://pica.zhimg.com/v2-d3de3e0fc972950e032bb98a847ad00d_720w.jpg?source=d16d100b"></noscript><img src="data:image/svg+xml;utf8,&lt;svg%20xmlns='http://www.w3.org/2000/svg'%20width='661'%20height='641'&gt;&lt;/svg&gt;" data-caption="" data-size="normal" data-rawwidth="661" data-rawheight="641" class="origin_image zh-lightbox-thumb lazy" width="661" data-original="https://pica.zhimg.com/v2-d3de3e0fc972950e032bb98a847ad00d_720w.jpg?source=d16d100b" data-actualsrc="https://picx.zhimg.com/v2-d3de3e0fc972950e032bb98a847ad00d_720w.jpg?source=d16d100b"></figure><p data-pid="AaRdYmdE">然后我们重新进行直线检测，实验结果表明此时已可以覆盖全部棋盘线，但是可以看到某些棋盘线由于有一定粗细，被识别成多条十分接近的直线。对于这些几乎重合的直线，我们只需要其中一条作为代表，下面进行筛选。</p><div class="highlight"><pre><code class="language-python"><span></span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">line_list</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">line_list</span> <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">mean</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
<span class="n">rows</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">line_list</span> <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">mean</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
<span class="n">cols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="n">rows</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">cols</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span><span class="n">cols</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">))</span> <span class="k">if</span> <span class="n">cols</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">cols</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">]</span>
<span class="n">rows</span> <span class="o">=</span> <span class="p">[</span><span class="n">rows</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span><span class="n">rows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">))</span> <span class="k">if</span> <span class="n">rows</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">rows</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">]</span>
<span class="n">pos_map</span> <span class="o">=</span> <span class="p">{(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rows</span><span class="p">)}</span>
</code></pre></div><p data-pid="vHsjX840">方法很简单，我们使用line_list存储所有直线的右端点或下端点，即 <img src="https://www.zhihu.com/equation?tex=t%3D-2000" alt="t=-2000" eeimg="1"> 时的点。接下来我们计算所有点横纵坐标的均值。如果一条直线的下端点的横坐标小于横坐标的平均值，那么它就是竖线，否则就是横线。对于竖线，我们按照其下端点的横坐标进行排序，之后从左到右将第一次与左边相邻直线相距超过10个像素点的直线加入过滤后的集合，对于横线也同理。这样我们就得到了过滤后的所有直线。</p><p data-pid="NEhrSdhd">然后对于竖线下端点的横坐标和横线右端点的纵坐标进行笛卡尔积，我们就得到了所有交叉点的坐标。这个方法只适用于这种横平竖直的数据，如果棋盘有畸变或歪斜，需要先矫正再处理，或者在这里改变一下交点的计算方法。</p><p data-pid="dgXsrL_P">接下来对于我们检测得到的棋子的圆心，只要判断它在哪个交叉点的小邻域内就好了：</p><div class="highlight"><pre><code class="language-python"><span></span><span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="n">steps</span><span class="p">:</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">step</span><span class="p">[</span><span class="s1">'center'</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">grid</span> <span class="ow">in</span> <span class="n">pos_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">step</span><span class="p">[</span><span class="s1">'number'</span><span class="p">],</span> <span class="n">grid</span><span class="p">)</span>
            <span class="k">break</span>
</code></pre></div><p data-pid="4zK1lvHL">这里直接使用L1距离进行判断。如果我们对横纵坐标分别查找，可以将复杂度从 <img src="https://www.zhihu.com/equation?tex=O%28n%5E2%29" alt="O(n^2)" eeimg="1"> 降低到 <img src="https://www.zhihu.com/equation?tex=O%282n%29" alt="O(2n)" eeimg="1"> ，考虑到数据的规则性，也可以直接使用哈希函数，将圆心坐标映射到对应的行和列的区间内，如此复杂度可降低到 <img src="https://www.zhihu.com/equation?tex=O%281%29" alt="O(1)" eeimg="1"> 。这里由于 <img src="https://www.zhihu.com/equation?tex=n%3D19" alt="n=19" eeimg="1"> 并不大，我懒得改了。最终我们可以得到这局棋的数字化表示：</p><div class="highlight"><pre><code class="language-text"><span></span>1 ( 3, 15)
2 ( 3,  3)
3 (15, 16)
4 (15,  3)
5 ( 2,  2)
6 ( 3,  2)
7 ( 2,  3)
...
</code></pre></div><p data-pid="u0gAcXGs">我这里直接编写了一个独立的程序，可以使用上篇文章中圆检测程序的中间结果，输出一盘棋所有步数的棋盘坐标。也可以将这些程序融合成一个可视化软件，当然也可以存储成通用的SGF格式，参考<a href="http://link.zhihu.com/?target=https%3A//blog.csdn.net/qq_41957257/article/details/90750279" class=" wrap external" target="_blank" rel="nofollow noreferrer">这篇文章</a>。另外我们可以从新浪围棋网爬虫得到SGF棋谱的GroundTruth，这样我们可以在大量数据下自动评估本文的识别算法的准确率。</p><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-2736c04eaa535e7869abf3ea1e7a307a_720w.jpg?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="2554" data-rawheight="1296" class="origin_image zh-lightbox-thumb" width="2554" data-original="https://pica.zhimg.com/v2-2736c04eaa535e7869abf3ea1e7a307a_720w.jpg?source=d16d100b"></noscript><img src="data:image/svg+xml;utf8,&lt;svg%20xmlns='http://www.w3.org/2000/svg'%20width='2554'%20height='1296'&gt;&lt;/svg&gt;" data-caption="" data-size="normal" data-rawwidth="2554" data-rawheight="1296" class="origin_image zh-lightbox-thumb lazy" width="2554" data-original="https://pica.zhimg.com/v2-2736c04eaa535e7869abf3ea1e7a307a_720w.jpg?source=d16d100b" data-actualsrc="https://pic1.zhimg.com/v2-2736c04eaa535e7869abf3ea1e7a307a_720w.jpg?source=d16d100b"></figure><h2>附录：完整代码</h2><div class="highlight"><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">pickle</span><span class="o">,</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="k">def</span> <span class="nf">circle_detection</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>
    <span class="n">gray</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>
    <span class="n">_gray</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">GaussianBlur</span><span class="p">(</span><span class="n">gray</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">max_radius</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="o">*</span><span class="n">_gray</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">//</span> <span class="mi">19</span>
    <span class="n">circles</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">HoughCircles</span><span class="p">(</span>
        <span class="n">image</span><span class="o">=</span><span class="n">_gray</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">HOUGH_GRADIENT</span><span class="p">,</span>
        <span class="n">dp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">minDist</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">param1</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">param2</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
        <span class="n">minRadius</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">maxRadius</span><span class="o">=</span><span class="mi">30</span>
    <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">circles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">circles</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">circles</span><span class="p">:</span>
        <span class="n">cv2</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="mi">50</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">circles</span><span class="p">:</span>
        <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">cv2</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">cv2</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y1</span><span class="p">),</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y2</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">#     plt.figure(figsize=(10, 10), dpi=80)</span>
<span class="c1">#     plt.imshow(image)</span>
    <span class="k">return</span> <span class="n">image</span>

<span class="k">def</span> <span class="nf">line_detection</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>
    <span class="n">gray</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">image</span><span class="p">,</span><span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">Canny</span><span class="p">(</span><span class="n">gray</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">apertureSize</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">HoughLines</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
    <span class="n">line_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
        <span class="n">rho</span><span class="p">,</span><span class="n">theta</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">rho</span>
        <span class="n">y0</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">rho</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x0</span> <span class="o">-</span> <span class="mi">2000</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">b</span><span class="p">))</span>
        <span class="n">y1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">y0</span> <span class="o">-</span> <span class="mi">2000</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x0</span> <span class="o">+</span> <span class="mi">2000</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span><span class="p">))</span>
        <span class="n">y2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">y0</span> <span class="o">+</span> <span class="mi">2000</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span><span class="p">))</span>
        <span class="n">line_list</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">])</span>
    <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">line_list</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">line_list</span> <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">mean</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">line_list</span> <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">mean</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">cols</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span><span class="n">cols</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">))</span> <span class="k">if</span> <span class="n">cols</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">cols</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">]</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="p">[</span><span class="n">rows</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span><span class="n">rows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">))</span> <span class="k">if</span> <span class="n">rows</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">rows</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">]</span>
    <span class="n">pos_map</span> <span class="o">=</span> <span class="p">{(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rows</span><span class="p">)}</span>
    <span class="k">return</span> <span class="n">pos_map</span>

<span class="n">src</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="s2">"./test.jpg"</span><span class="p">)</span>
<span class="c1"># plt.figure(figsize=(10, 10), dpi=80)</span>
<span class="c1"># plt.imshow(src)</span>

<span class="n">pos_map</span> <span class="o">=</span> <span class="n">line_detection</span><span class="p">(</span><span class="n">circle_detection</span><span class="p">(</span><span class="n">src</span><span class="p">))</span>
<span class="n">steps</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s2">"test.jpg"</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">"."</span><span class="p">,</span> <span class="s2">"_"</span><span class="p">)</span> <span class="o">+</span> <span class="s1">'steps.pkl'</span><span class="p">,</span><span class="s1">'rb'</span><span class="p">))</span>

<span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="n">steps</span><span class="p">:</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">step</span><span class="p">[</span><span class="s1">'center'</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">grid</span> <span class="ow">in</span> <span class="n">pos_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">step</span><span class="p">[</span><span class="s1">'number'</span><span class="p">],</span> <span class="n">grid</span><span class="p">)</span>
            <span class="k">break</span>
</code></pre></div><p><br></p><hr><ul><li data-pid="1HbGvqUI"><b>2021年3月19日更新</b></li></ul><p data-pid="IoftrleK">爬取新浪围棋网指定page的全部棋谱的代码如下，sgf_dec得到的是解析后的棋谱，是一个由每一步的落子坐标组成的列表，元素顺序即为落子顺序，列表长度即为总手数。</p><div class="highlight"><pre><code class="language-python"><span></span><span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">BeautifulSoup</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="n">page</span> <span class="o">=</span> <span class="mi">121</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"http://sinago.com/gibo/new_gibo.asp?cur_page=</span><span class="si">%d</span><span class="s2">"</span> <span class="o">%</span> <span class="n">page</span><span class="p">)</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
<span class="n">sgf_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="s1">'href'</span><span class="p">][</span><span class="nb">len</span><span class="p">(</span><span class="s2">"JavaScript:gibo_load('"</span><span class="p">):</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="s2">"');"</span><span class="p">)]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">"a"</span><span class="p">)</span> <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="s1">'href'</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">"JavaScript"</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">sgf_link</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">sgf_list</span><span class="p">)):</span>
    <span class="n">sgf_raw</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sgf_link</span><span class="p">)</span><span class="o">.</span><span class="n">text</span>
    <span class="n">sgf_dec</span> <span class="o">=</span> <span class="p">[(</span><span class="nb">ord</span><span class="p">(</span><span class="n">step</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s1">'a'</span><span class="p">),</span> <span class="nb">ord</span><span class="p">(</span><span class="n">step</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s1">'a'</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sgf_raw</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">"()"</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">";"</span><span class="p">)[</span><span class="mi">1</span><span class="p">:])]</span>
</code></pre></div><p data-pid="mf_h2vFQ">下面是在Ubuntu下自动获取对应的棋谱图片的实验。目前网上缺乏将SGF直接转为可打印的黑白SVG图像的网站，新浪围棋的打印功能是我找到的唯一一个满足需求的。目前可使用cutycapt和xvfb配合对指定网页进行截图，安装方法：</p><div class="highlight"><pre><code class="language-bash"><span></span>sudo apt-get install cutycapt xvfb
</code></pre></div><p data-pid="ityV_tCE">之后我们还需要安装中文字体依赖，使用如下命令检测系统是否具有中文字体：</p><div class="highlight"><pre><code class="language-bash"><span></span>fclist :lang<span class="o">=</span>zh
</code></pre></div><p data-pid="6DfJnyEt">如果没有，我们可以在网上下载ttc字体文件，如果是Mac电脑，可以在本地使用以上命令查看各个字体所在的文件路径。我是将<code>/System/Library/Fonts/PingFang.ttc</code>直接使用scp命令拷贝到Ubuntu下的。注意存放路径要在<code>/usr/share/fonts/truetype/</code>下面，这样就可以被fclist自动识别。接下来我们使用cutycapt对棋谱页面截图：</p><div class="highlight"><pre><code class="language-bash"><span></span>xvfb-run --server-args<span class="o">=</span><span class="s2">"-screen 0, 1920x1080x24"</span> cutycapt --url<span class="o">=</span>http://sinago.com/gibo_new/giboviewer/giboprint.asp?gibo<span class="o">=</span>http://sinago.com/cgibo/20188/nz6wj11-1808246.sgf --out<span class="o">=</span>ss.jpg
</code></pre></div><p data-pid="UM6N9Hvx">这里的链接里gibo=后面的链接可以替换成上面的爬虫代码中得到的sgf_link。查看输出的图片文件ss.jpg，接下来只需要写一些自动裁剪的代码就行了，在此不再赘述。如果觉得图片不够清晰，可以参考<a href="http://link.zhihu.com/?target=http%3A//cutycapt.sourceforge.net/" class=" wrap external" target="_blank" rel="nofollow noreferrer">cutycapt的文档</a>，使用缩放功能或者调整xvfb的屏幕分辨率，毕竟SVG图片不会对缩放失真。另外推荐一个linux上的SVG转图片的工具<a href="http://link.zhihu.com/?target=https%3A//www.systutorials.com/docs/linux/man/1-inkscape/" class=" wrap external" target="_blank" rel="nofollow noreferrer">inkscape</a>，但由于我们不加载JS是无法获取到SVG的结果的，这里不使用这种方案。</p><figure data-size="normal"><noscript><img src="https://picx.zhimg.com/v2-2f750e88bb95fb84115e014cbe4c0c8e_720w.jpg?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="801" data-rawheight="1122" class="origin_image zh-lightbox-thumb" width="801" data-original="https://pic1.zhimg.com/v2-2f750e88bb95fb84115e014cbe4c0c8e_720w.jpg?source=d16d100b"></noscript><img src="data:image/svg+xml;utf8,&lt;svg%20xmlns='http://www.w3.org/2000/svg'%20width='801'%20height='1122'&gt;&lt;/svg&gt;" data-caption="" data-size="normal" data-rawwidth="801" data-rawheight="1122" class="origin_image zh-lightbox-thumb lazy" width="801" data-original="https://pic1.zhimg.com/v2-2f750e88bb95fb84115e014cbe4c0c8e_720w.jpg?source=d16d100b" data-actualsrc="https://picx.zhimg.com/v2-2f750e88bb95fb84115e014cbe4c0c8e_720w.jpg?source=d16d100b"></figure><p data-pid="iVFWTQ_Z">有了图片数据集和真实标签，大家可以搞起来了！也可以尝试一下别的方法，比如深度学习之类的~</p>