<p data-pid="VawhpFUD">这是今年2月份清川发在CSDN上的文章。由于看不惯CSDN的发展走向，清川重写了他的个人网站，并将一部分内容搬运过来。</p><a href="http://link.zhihu.com/?target=https%3A//liushangyu.xyz/" data-draft-node="block" data-draft-type="link-card" data-image="https://pic1.zhimg.com/v2-d49e0205c58417bea5c5bbf8483f3353_l.jpg?source=d16d100b" data-image-width="886" data-image-height="886" class=" wrap external" target="_blank" rel="nofollow noreferrer">人间纪行 - 清川</a><p data-pid="YWQ18aiE">时过境迁，这篇文章读起来仍然津津有味。楔子里提到的验收学长后来和我实习时碰巧同一个实验室，我才明白课设被怼不是我的问题，是学长本身比较有性格，和谁说话都那样。后来还参加了公司组织的趣味运动会，和验收时的老师一起合了影，而她应该都不记得我是谁。有些事情该放下就要放下，人不能活在偏执里，这样才能成长。</p><hr><h2>写在前面</h2><blockquote data-pid="AvvifusO"> 话痨预警！</blockquote><p data-pid="9CSGcEzl">我永远忘不了本科时代编译原理的课程设计，那是我成年后的第一次崩溃。选题要求可以做编译器的前端、后端或者两者都做，评估了一下所带领的开发团队的实力，毅然决然选择只做前端，把前端做精，并且为后端开发留好接口。两个星期，我艰（dan）苦（da）开（du）发（dou），几乎都熬到凌晨3:00，发布前还通宵调试，终于我认定我做了一个优秀的前端，拥有完美而丰富的功能。</p><p data-pid="LZmLWN1V">发布那天，验收的研究生学长说不想听我的介绍，只想看我打印出来的符号表。我说为了控制局部变量的作用域，我的符号表是树状的，不好输出，可以在调试界面里更方便地查看所有变量。（实际上我也考虑过这一点，所以安排组员写过，也给他们讲了详细思路，但他们写了三天也没动静。）</p><p data-pid="WXbJDZG9">他瞥了一眼我CLion下的符号表，撇了撇嘴：“我可看不懂”。</p><p data-pid="ZYg7_fYp">“那我给你讲讲怎么看吧。”</p><p data-pid="OONowQWT">“我不听，我就要看你的输出。”</p><p data-pid="7KHxM1r5">“可是我说了我没有输出啊。”</p><p data-pid="yQyR5cX6">“那你不就什么都没做吗？”他叫来老师，“老师，你看他们还整个什么树状的啥，听都没听说过，还没输出，这事儿我管不了了，再管要干架。”</p><p data-pid="ANJSWt1I">我和老师复述了一遍情况，老师说：“那你这不就是啥都没做吗？你再看看要求，我们要的是输出，你别跟我扯没用的，连最基本的要求都达不到，你以后上企业也得被开除！”</p><p data-pid="UX-52Mm3">“我，我...我原来什么都没做。”我没忍住眼泪，垂下头慢慢哭了出来。全班同学开始帮我求情，“老师，你仔细看看吧，他们组做的可好了，比我们都复杂。”</p><p data-pid="2VogBBFp">“你和他一组的？”</p><p data-pid="l09ozOFe">“不是啊”</p><p data-pid="wd_hDEaC">“不是你帮他说什么话。这样吧，再给你个机会，我还没上成绩，明天你们组把输出拿出来，我还可以考虑考虑。本来就做的少，想得高分没那么简单。”</p><p data-pid="rhKCEl_i">那一天我喝了几罐啤酒，思考着为什么教学不尊重创新和实用，为什么十几项特色的功能会被一个没有用的输出抹掉，为什么别的组只是把GCC包个壳子也能得到优秀。思考良久，我觉得成年人要学会看领导脸色。我用一个小时写完了树表输出，用上了前一年在数据结构课设中发明的树表输出算法。我给老师写了一封致歉信，并把输出贴了上去，最终得到了一个卑微的优秀。</p><p data-pid="l8ANPTEa">从此，我对编译器设计耿耿于怀，几乎和认识的学弟学妹都说过：“你们参考一下<a href="http://link.zhihu.com/?target=http%3A//www.lysator.liu.se/c/ANSI-C-grammar-y.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">ANSIC的开源文法</a>还有GCC的内联汇编，你们可以编译到这种汇编，然后用GCC内置工具直接汇编成Win10下的可执行程序，一定很优秀。（这样就圆了老学长当年的遗憾）”</p><h2>GAS汇编</h2><p data-pid="KOi_y0wu">为了编译到GCC内联汇编，我们必须先掌握这种汇编的语法。经过一番苦查，我几乎什么有用的都没找到，直到现在，我才意识到是关键词打开的不对。不是<code>AT&amp;T汇编</code>，也不是<code>GCC内联汇编</code>，也不是<code>windows x64 汇编</code>，而应该是<code>GAS汇编</code>。</p><p data-pid="_F2k2PlZ">基于<code>x86</code>架构的处理器所使用的汇编指令一般有两种格式： </p><ul><li data-pid="txMxchgE"><code>Intel</code>汇编</li><li data-pid="TY4g8mGm"><code>AT&amp;T</code>汇编</li></ul><p data-pid="f737OsLL">汇编器也包括两大派系（当然也有其他的，在此不逐一枚举）： </p><ul><li data-pid="hYm1a8HK"><code>MS VC</code>编译器所使用的</li><li data-pid="RktWRsyL"><code>GNU CC</code>编译器所使用的</li></ul><p data-pid="2FTqttYA">前者只支持<code>Intel</code>格式，在<code>x86</code>处理器上的汇编器是<code>MASM.EXE</code>，链接器是<code>LINK.EXE</code>，在<code>x64</code>下的汇编器是<code>ml64.exe</code>，链接器是64位的<code>link.exe</code>。<code>x86</code>上的<code>Intel</code>汇编就包括我们耳熟能详的<code>王爽8086汇编</code>。当年想在Win10上运行这种16位的程序，只有调用<code>DOSBox</code>虚拟机。我曾经尝试编写支持8086汇编的IDE，读了<code>DOSBox</code>长篇README，已经实现了IO流和错误流的传递，唯独无法实现虚拟机窗口的隐藏。尝试从源码修改rebuild，又因为没有<code>Visual Studio</code>而以失败告终。微软<code>x64</code>下的<code>toolchain</code>实际上已经包含在<code>VS</code>里了，但对于一个电脑带不动<code>VS</code>的苦逼，我只能绕道。我尝试过<code>NASM</code>汇编器，但也由于得不到微软的链接器而走到死胡同。</p><p data-pid="YBSlhJnY">后者同时支持两个格式，并且跨平台，在<code>Windows</code>、<code>Linux</code>、<code>Unix</code>、<code>Mac OS</code>、<code>iOS(模拟器)</code>上都可。它的汇编器即为<code>GNU Assembler</code>，简称<code>GAS</code>，这就是我们今天议题的由来了。<code>GNU</code>的核心精神是自由与分享，所以<code>GAS</code>亦是自由软件，你看，这多好。<code>GCC</code>配套的链接工具是<code>ld.exe</code>，不过我们可以直接使用<code>gcc</code>从上层调用。</p><p data-pid="psXz54-_">换了关键词后，我一下子找到了GAS的文档：<a href="http://link.zhihu.com/?target=https%3A//sourceware.org/binutils/docs/as/index.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">Using as</a>。当然我猜这是一份Linux上的文档，因为Linux上的GAS就是as命令。接下来喜欢研究轮子的我就从头实验了。当然，了解这些，除了为编译器设计做铺垫，对于学习C语言嵌入GCC内联汇编以及读懂linux核心代码都会有帮助，也会加深对C语言底层的理解。</p><h2>实验分析</h2><h3>最小框架</h3><p data-pid="8aOU0FuU">我是通过<code>gcc -S</code>这个命令入的坑。我相信写过C语言的人对GCC都不会陌生（VS党除外）。这个指令大家也应该熟悉，它可以生成GAS汇编中间代码。例如如下最简单的C语言源程序<code>test.c</code>：</p><div class="highlight"><pre><code class="language-c"><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="mi">0</span><span class="p">;}</span>
</code></pre></div><p data-pid="_mLc2Qz3">使用如下命令：</p><div class="highlight"><pre><code class="language-powershell"><span></span><span class="n">gcc</span> <span class="n">-S</span> <span class="n">-fno-asynchronous-unwind-tables</span> <span class="n">test</span><span class="p">.</span><span class="n">c</span>
</code></pre></div><p data-pid="KfYa8Y4K">你可以得到<code>test.s</code>：</p><div class="highlight"><pre><code class="language-nasm"><span></span><span class="nf">.file</span>   <span class="s">"hello_test.c"</span>
    <span class="nf">.def</span>    <span class="nv">__main</span><span class="c1">; .scl    2;  .type   32; .endef</span>
    <span class="nf">.text</span>
    <span class="nf">.globl</span>  <span class="nv">main</span>
    <span class="nf">.def</span>    <span class="nv">main</span><span class="c1">;   .scl    2;  .type   32; .endef</span>
<span class="nl">main:</span>
    <span class="nf">pushq</span>   <span class="o">%</span><span class="nb">rbp</span>
    <span class="nf">movq</span>    <span class="o">%</span><span class="nb">rsp</span><span class="p">,</span> <span class="o">%</span><span class="nb">rbp</span>
    <span class="nf">subq</span>    <span class="kc">$</span><span class="mi">32</span><span class="p">,</span> <span class="o">%</span><span class="nb">rsp</span>
    <span class="nf">call</span>    <span class="nv">__main</span>
    <span class="nf">movl</span>    <span class="kc">$</span><span class="mi">0</span><span class="p">,</span> <span class="o">%</span><span class="nb">eax</span>
    <span class="nf">leave</span>
    <span class="nf">ret</span>
    <span class="nf">.ident</span>  <span class="s">"GCC: (GNU) 5.2.0"</span>
</code></pre></div><p data-pid="s7icbo1A"><code>-fno-asynchronous-unwind-tables</code>参数是为了去除复杂的<code>Seh</code>指令，你也可以尝试不加参数看一下结果。关于<code>seh_*</code>，在<code><a href="http://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/20819927/what-are-seh-assembly-commands-that-gcc-outputs/20820273" class=" wrap external" target="_blank" rel="nofollow noreferrer">stack overflow</a></code>中有提到。大概是说这是gas对MASM中为了生成可执行程序的.pdata和.xdata段的框架处理伪指令的实现。</p><blockquote data-pid="CJgYhyo_"> These are gas's implementation of MASM's frame handling pseudos for generating an executable's .pdata and .xdata sections</blockquote><p data-pid="Pih1gijn">那么以上汇编程序每行的含义是什么呢？其中<code>.file</code>、<code>.def</code>、<code>.ident</code>都是一些表示调试信息的伪指令，可以忽略，下文的代码中会将它们删掉，不影响运行。当然也可以参考<a href="http://link.zhihu.com/?target=https%3A//blog.csdn.net/weixin_34043301/article/details/92026592" class=" wrap external" target="_blank" rel="nofollow noreferrer">GAS汇编器伪指令大全</a>，<code>.</code>开头的一般都是伪指令。接下来<code>.text</code>表示代码段的开始，<code>.globl main</code>声明了全局的函数<code>main</code>。因为<code>gcc</code>默认要求程序入口必须是<code>main</code>，所以这里和下面的<code>main:</code>都是固定的。（也可以使用<code>ld.exe</code>手动链接并在参数中指定主函数入口。）接下来将寄存器<code>rbp</code>的值入栈，将栈顶指针寄存器<code>rsp</code>保存在<code>rbp</code>中，将栈顶指针<code>rsp</code>减去32，调用<code>__main</code>内置入口，什么都不做，然后将返回值0保存在<code>eax</code>寄存器中，退出程序，返回。这就是一个程序的最小框架。我们总结一些摸索出来的知识：</p><ul><li data-pid="aEVEn7Xv">指令的<code>b</code>、<code>w</code>、<code>l</code>、<code>q</code>后缀分别表示操作数为<code>1Byte</code>、<code>2Byte</code>(1 word)、<code>4Byte</code>(1 long word)、<code>8Byte</code>(1 quadra word)。在x64中，64位地址刚好对应<code>q</code>。参考<a href="http://link.zhihu.com/?target=https%3A//blog.csdn.net/chentaoxie/article/details/99091023" class=" wrap external" target="_blank" rel="nofollow noreferrer">AT&amp;T汇编-参考</a>。</li></ul><figure data-size="normal"><noscript><img src="https://pic1.zhimg.com/v2-33364d64998da8089a8a9ac32cd1903c_720w.jpg?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="622" data-rawheight="666" class="origin_image zh-lightbox-thumb" width="622" data-original="https://pic1.zhimg.com/v2-33364d64998da8089a8a9ac32cd1903c_720w.jpg?source=d16d100b"></noscript><img src="data:image/svg+xml;utf8,&lt;svg%20xmlns='http://www.w3.org/2000/svg'%20width='622'%20height='666'&gt;&lt;/svg&gt;" data-caption="" data-size="normal" data-rawwidth="622" data-rawheight="666" class="origin_image zh-lightbox-thumb lazy" width="622" data-original="https://pic1.zhimg.com/v2-33364d64998da8089a8a9ac32cd1903c_720w.jpg?source=d16d100b" data-actualsrc="https://pic1.zhimg.com/v2-33364d64998da8089a8a9ac32cd1903c_720w.jpg?source=d16d100b"></figure><ul><li data-pid="xziJLANu"><code>x64</code>中的寄存器如图所示。很好记的是，这和<code>8086Intel汇编</code>的寄存器有相似之处。<code>ax</code>，<code>bx</code>，<code>cx</code>，<code>dx</code>，<code>si</code>，<code>di</code>，<code>bp</code>，<code>sp</code>都一样。只不过32位的在前面加上<code>e</code>，64位的在前面加上<code>r</code>。可能是<code>extend</code>和<code>re-extend</code>吧，我猜测。作用也相似，前面带<code>x</code>是通用寄存器，然后分别为变址、目的变址、基址和栈顶指针寄存器。剩下的寄存器名则是从<code>r8</code> ~ <code>r15</code>，分别用后缀<code>d</code>，<code>w</code>，<code>b</code>指定位宽。</li><li data-pid="u__sqFej">栈顶在低地址，栈底在高地址，入栈时<code>rsp</code>减小。这也与我们C语言所讲的堆栈分配相统一。</li><li data-pid="rdsc026x">使用<code>#</code>作为注释开头，而不是<code>Intel汇编</code>的<code>;</code>。</li><li data-pid="dt7t0i2h"><code>AT&amp;T汇编</code>指令的源、目的操作数顺序和<code>Intel汇编</code>相反：<code>mov src, dst</code>。但在算术运算时两者相同，<code>sub 减数, 被减数</code>。</li><li data-pid="YAG_GmQy"><code>leave</code>指令等价于<code>movq %rbp, %rsp</code>，<code>popq %rbp</code></li></ul><h3>变量定义</h3><p data-pid="A_SdfP5_">接下来我们尝试插入最简单的变量定义：</p><div class="highlight"><pre><code class="language-c"><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">var</span> <span class="o">=</span> <span class="mi">99</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p data-pid="PRUwhJKn">生成GAS后可以看到变化：</p><div class="highlight"><pre><code class="language-nasm"><span></span><span class="nf">.text</span>
    <span class="nf">.globl</span>  <span class="nv">main</span>
<span class="nl">main:</span>
    <span class="nf">pushq</span>   <span class="o">%</span><span class="nb">rbp</span>
    <span class="nf">movq</span>    <span class="o">%</span><span class="nb">rsp</span><span class="p">,</span> <span class="o">%</span><span class="nb">rbp</span>
    <span class="nf">subq</span>    <span class="kc">$</span><span class="mi">48</span><span class="p">,</span> <span class="o">%</span><span class="nb">rsp</span>       <span class="err">#</span> <span class="err">这里</span>
    <span class="nf">call</span>    <span class="nv">__main</span>
    <span class="nf">movl</span>    <span class="kc">$</span><span class="mi">99</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">(</span><span class="o">%</span><span class="nb">rbp</span><span class="p">)</span>   <span class="err">#</span> <span class="err">这里</span>
    <span class="nf">movl</span>    <span class="kc">$</span><span class="mi">0</span><span class="p">,</span> <span class="o">%</span><span class="nb">eax</span>
    <span class="nf">leave</span>
    <span class="nf">ret</span>
</code></pre></div><p data-pid="7enPiCf9">注意要赋值，否则编译器会将未使用的变量优化没。栈顶<code>rsp</code>向下多移动了<code>16</code>，很明显，变量<code>var</code>被存在了地址<code>rsp - 4</code>，这与C语言局部变量存在栈区相一致，而且能看出当前平台下，编译器认为<code>int</code>占<code>4</code>个字节。那么<code>rsp</code>移动<code>4</code>不就行了，为啥动了<code>16</code>。我们多定义几个变量试试，实验表明，每次分配超出栈顶，就会增长<code>16</code>，这是个增量为<code>16</code>的顺序栈。也就是说，定义<code>5</code>个<code>int</code>型变量时，这里会变成<code>subq   $64, %rsp</code>。补充摸索出来的知识：</p><ul><li data-pid="aNj1YoVg">立即数以<code>$</code>开头，寄存器以<code>%</code>开头</li><li data-pid="NwNU88tb"><code>movl $99, -4(%rbp)</code>的目标操作数是一种寄存器基址寻址，会将<code>rbp</code>的值与<code>-4</code>相加。寻址方法可以参考<a href="http://link.zhihu.com/?target=http%3A//blog.chinaunix.net/uid-7874697-id-2037989.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">AT&amp;T指令集</a>的操作数格式一节。</li></ul><h3>输入输出</h3><p data-pid="YyQPwmft">我们在源码中加入输出语句：</p><div class="highlight"><pre><code class="language-c"><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"hello world</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p data-pid="--OIwXGR">得到GAS汇编代码：</p><div class="highlight"><pre><code class="language-nasm"><span></span><span class="nl">.LC0:</span>
    <span class="nf">.ascii</span> <span class="s">"hello world\0"</span>
    <span class="nf">.text</span>
    <span class="nf">.globl</span>  <span class="nv">main</span>
<span class="nl">main:</span>
    <span class="nf">pushq</span>   <span class="o">%</span><span class="nb">rbp</span>
    <span class="nf">movq</span>    <span class="o">%</span><span class="nb">rsp</span><span class="p">,</span> <span class="o">%</span><span class="nb">rbp</span>
    <span class="nf">subq</span>    <span class="kc">$</span><span class="mi">32</span><span class="p">,</span> <span class="o">%</span><span class="nb">rsp</span>
    <span class="nf">call</span>    <span class="nv">__main</span>
    <span class="nf">leaq</span>    <span class="nv">.LC0</span><span class="p">(</span><span class="o">%</span><span class="nv">rip</span><span class="p">),</span> <span class="o">%</span><span class="nb">rcx</span>
    <span class="nf">call</span>    <span class="nv">puts</span>
    <span class="nf">movl</span>    <span class="kc">$</span><span class="mi">0</span><span class="p">,</span> <span class="o">%</span><span class="nb">eax</span>
    <span class="nf">leave</span>
    <span class="nf">ret</span>
</code></pre></div><p data-pid="6zPBmaHJ">可以看到输出纯字符串的时候，会调用C语言的<code>puts</code>，前面使用<code>.ascii</code>声明了一个字符串，地址标记为<code>.LC0</code>。<code>lea src, dst</code>指令的意思是将<code>src</code>的值直接送到<code>dst</code>中，而不会对<code>src</code>再用一次间接寻址。配合<code>rip</code>寄存器（估计这里面默认存的是汇编程序开始的地址），<code>leaq .LC0(%rip), %rcx</code>一句会将<code>offset .LC0</code>存入<code>rcx</code>，也就是为<code>puts</code>准备字符串首地址。这种做法也叫相对寻址，参考<a href="http://link.zhihu.com/?target=https%3A//www.cnblogs.com/papertree/p/6298763.html" class=" wrap external" target="_blank" rel="nofollow noreferrer">从机器码理解RIP 相对寻址</a>。</p><p data-pid="DFys6kNt">那么我们让printf不单纯一下：</p><div class="highlight"><pre><code class="language-cpp"><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"I Know %d + %d = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">.</span><span class="nl">LC0</span><span class="p">:</span>
    <span class="p">.</span><span class="n">ascii</span> <span class="s">"I Know %d + %d = %d</span><span class="se">\12\0</span><span class="s">"</span>
    <span class="p">.</span><span class="n">text</span>
    <span class="p">.</span><span class="n">globl</span>  <span class="n">main</span>
<span class="nl">main</span><span class="p">:</span>
    <span class="n">pushq</span>   <span class="o">%</span><span class="n">rbp</span>
    <span class="n">movq</span>    <span class="o">%</span><span class="n">rsp</span><span class="p">,</span> <span class="o">%</span><span class="n">rbp</span>
    <span class="n">subq</span>    <span class="err">$</span><span class="mi">32</span><span class="p">,</span> <span class="o">%</span><span class="n">rsp</span>
    <span class="n">call</span>    <span class="n">__main</span>
    <span class="n">movl</span>    <span class="err">$</span><span class="mi">2</span><span class="p">,</span> <span class="o">%</span><span class="n">r9d</span>
    <span class="n">movl</span>    <span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="n">r8d</span>
    <span class="n">movl</span>    <span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="n">edx</span>
    <span class="n">leaq</span>    <span class="p">.</span><span class="n">LC0</span><span class="p">(</span><span class="o">%</span><span class="n">rip</span><span class="p">),</span> <span class="o">%</span><span class="n">rcx</span>
    <span class="n">call</span>    <span class="n">printf</span>
    <span class="n">movl</span>    <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="o">%</span><span class="n">eax</span>
    <span class="n">leave</span>
    <span class="n">ret</span>
</code></pre></div><p data-pid="--g6u7L6">可以看到汇编调用了<code>printf</code>函数，第一个参数是通过<code>rcx</code>寄存器指出格式字符串地址，接下来依次使用<code>rdx</code>、<code>r8</code>、<code>r9</code>，超出的将会使用栈来传递，这是函数调用的通用传递方法。压栈顺序为参数的逆序入栈。 </p><figure data-size="normal"><noscript><img src="https://picx.zhimg.com/v2-32b8d29e4d4a751e537a31691e960743_720w.jpg?source=d16d100b" data-caption="" data-size="normal" data-rawwidth="554" data-rawheight="303" class="origin_image zh-lightbox-thumb" width="554" data-original="https://pic1.zhimg.com/v2-32b8d29e4d4a751e537a31691e960743_720w.jpg?source=d16d100b"></noscript><img src="data:image/svg+xml;utf8,&lt;svg%20xmlns='http://www.w3.org/2000/svg'%20width='554'%20height='303'&gt;&lt;/svg&gt;" data-caption="" data-size="normal" data-rawwidth="554" data-rawheight="303" class="origin_image zh-lightbox-thumb lazy" width="554" data-original="https://pic1.zhimg.com/v2-32b8d29e4d4a751e537a31691e960743_720w.jpg?source=d16d100b" data-actualsrc="https://picx.zhimg.com/v2-32b8d29e4d4a751e537a31691e960743_720w.jpg?source=d16d100b"></figure><p data-pid="RwY38w1z"> 上图是<code>x86</code>中的，<code>32位</code>CPU只使用栈来传递参数，而<code>Win64</code>的前4个参数使用寄存器代替了。然而栈仍然会保存前4个参数的位置，以便回写，参考<a href="http://link.zhihu.com/?target=http%3A//www.360doc.com/content/14/1221/21/3242454_434681142.shtml" class=" wrap external" target="_blank" rel="nofollow noreferrer">windows x64编程中寄存器的使用</a>。以下部分不正确，感谢 <a class="member_mention" href="http://www.zhihu.com/people/4b124278b3561500b8ff59d7f75115fd" data-hash="4b124278b3561500b8ff59d7f75115fd" data-hovercard="p$b$4b124278b3561500b8ff59d7f75115fd">@大别山帅大叔</a> 的指正，C语言的参数执行顺序是未定义的，依赖于具体的编译器，我的机子上的结果恰好相反是从左往右的顺序。</p><blockquote data-pid="-uD7qCXO">这部分有误 begin</blockquote><p data-pid="MJdq0LSP">逆序入栈让我想起了舍友问过我的一道考研C语言题，大概是这样：</p><div class="highlight"><pre><code class="language-c"><span></span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d %d %d"</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">++</span><span class="p">,</span> <span class="n">b</span> <span class="o">++</span><span class="p">);</span>
</code></pre></div><p data-pid="_ds0djIe">问输出结果，实际上执行顺序是<code>b ++ =&gt; a ++ =&gt; a + b</code>，所以结果应该是<code>5 1 2</code>。</p><blockquote data-pid="ypD_LOVL">这部分有误 end</blockquote><p data-pid="nNvF63QZ">我们加入<code>scanf</code>试一下：</p><div class="highlight"><pre><code class="language-c"><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">var</span><span class="p">;</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">var</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p data-pid="rlkufR0Z">我们可以得到类似的结果</p><div class="highlight"><pre><code class="language-nasm"><span></span><span class="nl">.LC0:</span>
    <span class="nf">.ascii</span> <span class="s">"%d\0"</span>
    <span class="nf">.text</span>
    <span class="nf">.globl</span>  <span class="nv">main</span>
<span class="nl">main:</span>
    <span class="nf">pushq</span>   <span class="o">%</span><span class="nb">rbp</span>
    <span class="nf">movq</span>    <span class="o">%</span><span class="nb">rsp</span><span class="p">,</span> <span class="o">%</span><span class="nb">rbp</span>
    <span class="nf">subq</span>    <span class="kc">$</span><span class="mi">48</span><span class="p">,</span> <span class="o">%</span><span class="nb">rsp</span>
    <span class="nf">call</span>    <span class="nv">__main</span>
    <span class="nf">leaq</span>    <span class="o">-</span><span class="mi">4</span><span class="p">(</span><span class="o">%</span><span class="nb">rbp</span><span class="p">),</span> <span class="o">%</span><span class="nb">rax</span>
    <span class="nf">movq</span>    <span class="o">%</span><span class="nb">rax</span><span class="p">,</span> <span class="o">%</span><span class="nb">rdx</span>
    <span class="nf">leaq</span>    <span class="nv">.LC0</span><span class="p">(</span><span class="o">%</span><span class="nv">rip</span><span class="p">),</span> <span class="o">%</span><span class="nb">rcx</span>
    <span class="nf">call</span>    <span class="nv">scanf</span>
    <span class="nf">movl</span>    <span class="kc">$</span><span class="mi">0</span><span class="p">,</span> <span class="o">%</span><span class="nb">eax</span>
    <span class="nf">leave</span>
    <span class="nf">ret</span>
</code></pre></div><p data-pid="q8dye4Ye">注意这里的不同之处，<code>leaq -4(%rbp), %rax</code>，使用的是<code>leaq</code>而不是<code>movq</code>。这提醒我们C语言使用<code>scanf</code>的时候一定要考虑<code>&amp;</code>的问题。输入整型不加和号，必然<code>Runtime Error</code>。</p><h3>循环 &amp; 数组</h3><p data-pid="ShAJlyIw">加入循环和数组， 让代码逐渐变态：</p><div class="highlight"><pre><code class="language-c"><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d sheep jumped</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p data-pid="aE-gBNLR">汇编代码一下子长了很多：</p><div class="highlight"><pre><code class="language-nasm"><span></span><span class="nl">.LC0:</span>
    <span class="nf">.ascii</span> <span class="s">"%d\0"</span>
<span class="nl">.LC1:</span>
    <span class="nf">.ascii</span> <span class="s">"%d sheep jumped\12\0"</span>
    <span class="nf">.text</span>
    <span class="nf">.globl</span>  <span class="nv">main</span>
<span class="nl">main:</span>
    <span class="nf">pushq</span>   <span class="o">%</span><span class="nb">rbp</span>
    <span class="nf">movq</span>    <span class="o">%</span><span class="nb">rsp</span><span class="p">,</span> <span class="o">%</span><span class="nb">rbp</span>
    <span class="nf">subq</span>    <span class="kc">$</span><span class="mi">64</span><span class="p">,</span> <span class="o">%</span><span class="nb">rsp</span>
    <span class="nf">call</span>    <span class="nv">__main</span>
    <span class="nf">movl</span>    <span class="kc">$</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">(</span><span class="o">%</span><span class="nb">rbp</span><span class="p">)</span>
    <span class="nf">jmp</span> <span class="nv">.L2</span>
<span class="nl">.L3:</span>
    <span class="nf">leaq</span>    <span class="o">-</span><span class="mi">32</span><span class="p">(</span><span class="o">%</span><span class="nb">rbp</span><span class="p">),</span> <span class="o">%</span><span class="nb">rax</span>
    <span class="nf">movl</span>    <span class="o">-</span><span class="mi">4</span><span class="p">(</span><span class="o">%</span><span class="nb">rbp</span><span class="p">),</span> <span class="o">%</span><span class="nb">edx</span>
    <span class="nf">movslq</span>  <span class="o">%</span><span class="nb">edx</span><span class="p">,</span> <span class="o">%</span><span class="nb">rdx</span>
    <span class="nf">salq</span>    <span class="kc">$</span><span class="mi">2</span><span class="p">,</span> <span class="o">%</span><span class="nb">rdx</span>
    <span class="nf">addq</span>    <span class="o">%</span><span class="nb">rdx</span><span class="p">,</span> <span class="o">%</span><span class="nb">rax</span>
    <span class="nf">movq</span>    <span class="o">%</span><span class="nb">rax</span><span class="p">,</span> <span class="o">%</span><span class="nb">rdx</span>
    <span class="nf">leaq</span>    <span class="nv">.LC0</span><span class="p">(</span><span class="o">%</span><span class="nv">rip</span><span class="p">),</span> <span class="o">%</span><span class="nb">rcx</span>
    <span class="nf">call</span>    <span class="nv">scanf</span>
    <span class="nf">addl</span>    <span class="kc">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">(</span><span class="o">%</span><span class="nb">rbp</span><span class="p">)</span>
<span class="nl">.L2:</span>
    <span class="nf">cmpl</span>    <span class="kc">$</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">(</span><span class="o">%</span><span class="nb">rbp</span><span class="p">)</span>
    <span class="nf">jle</span> <span class="nv">.L3</span>
    <span class="nf">movl</span>    <span class="kc">$</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span><span class="p">(</span><span class="o">%</span><span class="nb">rbp</span><span class="p">)</span>
    <span class="nf">jmp</span> <span class="nv">.L4</span>
<span class="nl">.L5:</span>
    <span class="nf">movl</span>    <span class="o">-</span><span class="mi">8</span><span class="p">(</span><span class="o">%</span><span class="nb">rbp</span><span class="p">),</span> <span class="o">%</span><span class="nb">eax</span>
    <span class="nf">cltq</span>
    <span class="nf">movl</span>    <span class="o">-</span><span class="mi">32</span><span class="p">(</span><span class="o">%</span><span class="nb">rbp</span><span class="p">,</span><span class="o">%</span><span class="nb">rax</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="o">%</span><span class="nb">eax</span>
    <span class="nf">movl</span>    <span class="o">%</span><span class="nb">eax</span><span class="p">,</span> <span class="o">%</span><span class="nb">edx</span>
    <span class="nf">leaq</span>    <span class="nv">.LC1</span><span class="p">(</span><span class="o">%</span><span class="nv">rip</span><span class="p">),</span> <span class="o">%</span><span class="nb">rcx</span>
    <span class="nf">call</span>    <span class="nv">printf</span>
    <span class="nf">addl</span>    <span class="kc">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span><span class="p">(</span><span class="o">%</span><span class="nb">rbp</span><span class="p">)</span>
<span class="nl">.L4:</span>
    <span class="nf">cmpl</span>    <span class="kc">$</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">8</span><span class="p">(</span><span class="o">%</span><span class="nb">rbp</span><span class="p">)</span>
    <span class="nf">jle</span> <span class="nv">.L5</span>
    <span class="nf">movl</span>    <span class="kc">$</span><span class="mi">0</span><span class="p">,</span> <span class="o">%</span><span class="nb">eax</span>
    <span class="nf">leave</span>
    <span class="nf">ret</span>
</code></pre></div><p data-pid="MuHv5jNC">这里解释几个没见过的用法，剩下的就很简单了：</p><ul><li data-pid="jDrz8aHU"><code>movslq</code>：作符号扩展的4字节复制到8字节。</li><li data-pid="Gc2o_4wW"><code>salq</code>：算术左移，低位补0。</li><li data-pid="sztDZIZS"><code>cltq</code>：将4个字节扩展为8个字节，高字节填充符号位，参考<a href="http://link.zhihu.com/?target=https%3A//oomake.com/question/1671389%23answer_list_10850597" class=" wrap external" target="_blank" rel="nofollow noreferrer">回答</a>。</li><li data-pid="LMqEkRbX"><code>cmpl $2, -4(%rbp)</code>：相当于<code>i-2</code>，配合后面的<code>jle</code>，如果结果小于等于0就跳转。<code>jmp</code>是无条件跳转。</li><li data-pid="dezD9Wwx"><code>\12</code>就是<code>\n</code>，都可以。字符串要以<code>\0</code>结尾。</li><li data-pid="CGm_wGVb"><code>-32(%rbp,%rax,4)</code>采用伸缩化变址寻址，即为<code>rbp + rax * 4 - 32</code> </li></ul><blockquote data-pid="Z9ujIHaL"><b>这里唯一让人费解的是</b>偏移量<code>i</code>在加到<code>array</code>地址上的时候为什么要左移<code>2</code>，后面变址寻址的时候也让<code>rax * 4</code>，相当于也左移了<code>2</code>。之前基址寻址时对地址的加减是货真价实的直接加减，比如<code>-4(%rbp)</code>。有种说法是Intel的CPU高两位总线不用，这显然不合适，因为这里是低两位没用。还有说法认为是内存对齐，可是内存对齐不应该只发生在结构体中吗，而且64位CPU应该按照8位对齐，而且，array占用的栈空间是货真价实的12字节。<b>还请了解的大佬们不吝赐教，我是真的不会。</b></blockquote><p data-pid="YombdUNB">上段是之前的疑问，感谢 <a class="member_mention" href="http://www.zhihu.com/people/2ee4348dbee57a5a9741e85d68deb0e8" data-hash="2ee4348dbee57a5a9741e85d68deb0e8" data-hovercard="p$b$2ee4348dbee57a5a9741e85d68deb0e8">@nxkskf</a> 指正，<code>-4(%rbp)</code>和<code>-8(%rbp)</code>位置中分别存储了两次循环的计数值 <img src="https://www.zhihu.com/equation?tex=i" alt="i" eeimg="1"> 。它是一个4字节的整型数，要加到数组首地址<code>-32(%rbp)</code>上时需要先扩展到8字节，然后乘以4或者左移2，以得到数组对应元素的绝对地址。这是理所当然的事情，不知道当时为什么不理解。</p><p data-pid="AoH-LXqd">这里可以明显看到代码有很大的冗余，我们可以在编译的时候加入优化参数，如：</p><div class="highlight"><pre><code class="language-powershell"><span></span><span class="n">gcc</span> <span class="n">-O</span> <span class="n">test</span><span class="p">.</span><span class="n">c</span> <span class="n">-S</span>
</code></pre></div><p data-pid="8vPTNTDr">优化方式和区别参考<a href="http://link.zhihu.com/?target=https%3A//blog.csdn.net/kobemin/article/details/83180747" class=" wrap external" target="_blank" rel="nofollow noreferrer">GCC -O 优化等级详解</a>。优化出来的代码不太好懂，这里不再展开。但是我倒是可以利用刚才掌握的知识重写一份汇编，来实现同样的功能（好吧我只是抖个机灵）：</p><div class="highlight"><pre><code class="language-nasm"><span></span><span class="nl">.LC0:</span>
    <span class="nf">.ascii</span> <span class="s">"%d\0"</span>
<span class="nl">.LC1:</span>
    <span class="nf">.ascii</span> <span class="s">"%d sheep jumped\12\0"</span>
    <span class="nf">.text</span>
    <span class="nf">.globl</span>  <span class="nv">main</span>
<span class="nl">main:</span>
    <span class="nf">pushq</span>   <span class="o">%</span><span class="nb">rbp</span>
    <span class="nf">movq</span>    <span class="o">%</span><span class="nb">rsp</span><span class="p">,</span> <span class="o">%</span><span class="nb">rbp</span>
    <span class="nf">subq</span>    <span class="kc">$</span><span class="mi">48</span><span class="p">,</span> <span class="o">%</span><span class="nb">rsp</span>
    <span class="nf">call</span>    <span class="nv">__main</span>
    <span class="nf">movl</span>    <span class="kc">$</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">(</span><span class="o">%</span><span class="nb">rbp</span><span class="p">)</span>
    <span class="nf">jmp</span> <span class="nv">.L2</span>
<span class="nl">.L3:</span>
    <span class="nf">leaq</span>    <span class="o">-</span><span class="mi">16</span><span class="p">(</span><span class="o">%</span><span class="nb">rbp</span><span class="p">),</span> <span class="o">%</span><span class="nb">rax</span>
    <span class="nf">movl</span>    <span class="o">-</span><span class="mi">4</span><span class="p">(</span><span class="o">%</span><span class="nb">rbp</span><span class="p">),</span> <span class="o">%</span><span class="nb">edx</span>
    <span class="nf">movslq</span>  <span class="o">%</span><span class="nb">edx</span><span class="p">,</span> <span class="o">%</span><span class="nb">rdx</span>
    <span class="nf">salq</span>    <span class="kc">$</span><span class="mi">2</span><span class="p">,</span> <span class="o">%</span><span class="nb">rdx</span>
    <span class="nf">addq</span>    <span class="o">%</span><span class="nb">rax</span><span class="p">,</span> <span class="o">%</span><span class="nb">rdx</span>
    <span class="nf">leaq</span>    <span class="nv">.LC0</span><span class="p">(</span><span class="o">%</span><span class="nv">rip</span><span class="p">),</span> <span class="o">%</span><span class="nb">rcx</span>
    <span class="nf">call</span>    <span class="nv">scanf</span>
    <span class="nf">movl</span>    <span class="o">-</span><span class="mi">4</span><span class="p">(</span><span class="o">%</span><span class="nb">rbp</span><span class="p">),</span> <span class="o">%</span><span class="nb">eax</span>
    <span class="nf">cltq</span>
    <span class="nf">movl</span>    <span class="o">-</span><span class="mi">16</span><span class="p">(</span><span class="o">%</span><span class="nb">rbp</span><span class="p">,</span><span class="o">%</span><span class="nb">rax</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="o">%</span><span class="nb">edx</span>
    <span class="nf">leaq</span>    <span class="nv">.LC1</span><span class="p">(</span><span class="o">%</span><span class="nv">rip</span><span class="p">),</span> <span class="o">%</span><span class="nb">rcx</span>
    <span class="nf">call</span>    <span class="nv">printf</span>
    <span class="nf">addl</span>    <span class="kc">$</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">(</span><span class="o">%</span><span class="nb">rbp</span><span class="p">)</span>
<span class="nl">.L2:</span>
    <span class="nf">cmpl</span>    <span class="kc">$</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">(</span><span class="o">%</span><span class="nb">rbp</span><span class="p">)</span>
    <span class="nf">jle</span> <span class="nv">.L3</span>
    <span class="nf">movl</span>    <span class="kc">$</span><span class="mi">0</span><span class="p">,</span> <span class="o">%</span><span class="nb">eax</span>
    <span class="nf">leave</span>
    <span class="nf">ret</span>
</code></pre></div><p data-pid="4dLWNSEG">然后使用下面的命令将它汇编链接成可执行程序：</p><div class="highlight"><pre><code class="language-text"><span></span>gcc test.s -o test.exe
</code></pre></div><p data-pid="914v4jsZ">也可以加入<code>-v</code>参数看看gas汇编链接的过程，你会发现gcc先是调用了<code>as.exe</code>来汇编，然后调用了<code>collect2.exe</code>，这其中又调用了<code>ld.exe</code>链接。为了方便，我把GAS加入到了<code>sublime</code>的<code>build system</code>中。<code>gas.sublime-build</code>：</p><div class="highlight"><pre><code class="language-json"><span></span><span class="p">{</span>
    <span class="nt">"working_dir"</span><span class="p">:</span> <span class="s2">"${file_path}"</span><span class="p">,</span>
    <span class="nt">"shell_cmd"</span><span class="p">:</span> <span class="s2">"gcc ${file} -o ${file_base_name}.exe &amp;&amp; start cmd /c \"${file_base_name}.exe &amp; pause\""</span><span class="p">,</span>
    <span class="nt">"selector"</span><span class="p">:</span> <span class="p">[</span><span class="s2">"source.s"</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div><h2>写在后面</h2><p data-pid="kub89OKe">这篇文章的实验抛转引玉，之后的工作可以参照这个模式进行。根据设计的编译器文法考虑所需了解的汇编语法，然后逐个攻破。将汇编链接的命令行加入到编译器中，就可以发明一个跨平台、可执行的语言了。</p>